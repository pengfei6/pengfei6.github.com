<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Naruto-Pictures]]></title>
      <url>http://pengfei6.github.io/2016/09/13/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="http://oapjp6spr.bkt.clouddn.com/18210.jpg" alt=""></div><div class="group-picture-column" style="width: 50%;"><img src="http://oapjp6spr.bkt.clouddn.com/196232.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://oapjp6spr.bkt.clouddn.com/224147.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://oapjp6spr.bkt.clouddn.com/199301.jpg" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://oapjp6spr.bkt.clouddn.com/213318.jpg" alt=""></div></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016前端面试题整理]]></title>
      <url>http://pengfei6.github.io/2016/08/20/2016%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>HTML&amp;CSS</p>
<blockquote>
<p>对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应。</p>
</blockquote>
<p> JavaScript</p>
<blockquote>
<p>数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等。<br><a id="more"></a></p>
</blockquote>
<p> 综合</p>
<blockquote>
<p>HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯</p>
</blockquote>
<h1 id="CSS-相关问题"><a href="#CSS-相关问题" class="headerlink" title="CSS 相关问题"></a>CSS 相关问题</h1><h3 id="display-none和visibility-hidden的区别？"><a href="#display-none和visibility-hidden的区别？" class="headerlink" title="display:none和visibility:hidden的区别？"></a>display:none和visibility:hidden的区别？</h3><pre><code>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，
就当他从来不存在。

visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。
</code></pre><h3 id="CSS中-link-和-import-的区别是？"><a href="#CSS中-link-和-import-的区别是？" class="headerlink" title="CSS中 link 和@import 的区别是？"></a>CSS中 link 和@import 的区别是？</h3><pre><code>A：(1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重.
</code></pre><h3 id="position的absolute与fixed共同点与不同点"><a href="#position的absolute与fixed共同点与不同点" class="headerlink" title="position的absolute与fixed共同点与不同点"></a>position的absolute与fixed共同点与不同点</h3><pre><code>A：共同点：
1.改变行内元素的呈现方式，display被置为block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上

B不同点：
absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。
</code></pre><h3 id="介绍一下CSS的盒子模型？"><a href="#介绍一下CSS的盒子模型？" class="headerlink" title="介绍一下CSS的盒子模型？"></a>介绍一下CSS的盒子模型？</h3><pre><code>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;

2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).
</code></pre><h3 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h3><pre><code>   *   1.id选择器（ # myid）
        2.类选择器（.myclassname）
        3.标签选择器（div, h1, p）
        4.相邻选择器（h1 + p）
        5.子选择器（ul &gt; li）
        6.后代选择器（li a）
        7.通配符选择器（ * ）
        8.属性选择器（a[rel = &quot;external&quot;]）
        9.伪类选择器（a: hover, li:nthchild）

    *   可继承的样式： fontsize fontfamily color, textindent;

    *   不可继承的样式：border padding margin width height ;

    *   优先级就近原则，同权重情况下样式定义最近者为准;

    *   载入样式以最后载入的定位为准;

优先级为:


   !important &gt;  id &gt; class &gt; tag

   important 比 内联优先级高,但内联比 id 要高

CSS3新增伪类举例：


p:firstoftype 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:lastoftype  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:onlyoftype  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:onlychild    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nthchild(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
</code></pre><h3 id="列出display的值，说明他们的作用。position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#列出display的值，说明他们的作用。position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？"></a>列出display的值，说明他们的作用。position的值， relative和absolute分别是相对于谁进行定位的？</h3><pre><code>1.
  block 象块类型元素一样显示。
  inline 缺省值。象行内元素类型一样显示。
  inlineblock 象行内元素一样显示，但其内容象块类型元素一样显示。
  listitem 象块类型元素一样显示，并添加样式列表标记。

  2.
  *absolute
        生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。

  *fixed （老IE不支持）
        生成绝对定位的元素，相对于浏览器窗口进行定位。

  *relative
        生成相对定位的元素，相对于其在普通流中的位置进行定位。

  * static  默认值。没有定位，元素出现在正常的流中
  *（忽略 top, bottom, left, right zindex 声明）。

  * inherit 规定从父元素继承 position 属性的值。
</code></pre><h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><pre><code>CSS3实现圆角（borderradius），阴影（boxshadow），
对文字加特效（textshadow、），线性渐变（gradient），旋转（transform）
transform:rotate(9deg) scale(0.85,0.90) translate(0px,30px) skew(9deg,0deg);//旋转,缩放,定位,倾斜
增加了更多的CSS选择器  多背景 rgba
在CSS3中唯一引入的伪元素是::selection.
媒体查询，多栏布局
borderimage
</code></pre><h3 id="为什么要初始化CSS样式。"><a href="#为什么要初始化CSS样式。" class="headerlink" title="为什么要初始化CSS样式。"></a>为什么要初始化CSS样式。</h3><pre><code>    因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

    当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

* 最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）

    淘宝的样式初始化：
    body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
    body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
    h1, h2, h3, h4, h5, h6{ fontsize:100%; }
    address, cite, dfn, em, var { fontstyle:normal; }
    code, kbd, pre, samp { fontfamily:couriernew, courier, monospace; }
    small{ fontsize:12px; }
    ul, ol { liststyle:none; }
    a { textdecoration:none; }
    a:hover { textdecoration:underline; }
    sup { verticalalign:texttop; }
    sub{ verticalalign:textbottom; }
    legend { color:#000; }
    fieldset, img { border:0; }
    button, input, select, textarea { fontsize:100%; }
    table { bordercollapse:collapse; borderspacing:0; }
</code></pre><h3 id="对BFC规范的理解？"><a href="#对BFC规范的理解？" class="headerlink" title="对BFC规范的理解？"></a>对BFC规范的理解？</h3><pre><code>  BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。
（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）
</code></pre><h3 id="解释下-CSS-sprites，以及你要如何在页面或网站中使用它。"><a href="#解释下-CSS-sprites，以及你要如何在页面或网站中使用它。" class="headerlink" title="解释下 CSS sprites，以及你要如何在页面或网站中使用它。"></a>解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h3><pre><code>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“backgroundimage”，“background repeat”，“backgroundposition”的组合进行背景定位，backgroundposition可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了`http2`。
</code></pre><h1 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h1><h3 id="说说你对语义化的理解？"><a href="#说说你对语义化的理解？" class="headerlink" title="说说你对语义化的理解？"></a>说说你对语义化的理解？</h3><pre><code>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
</code></pre><h3 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><pre><code>（1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。

（2）、严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。

（3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

（4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。
</code></pre><h3 id="你知道多少种Doctype文档类型？"><a href="#你知道多少种Doctype文档类型？" class="headerlink" title="你知道多少种Doctype文档类型？"></a>你知道多少种Doctype文档类型？</h3><pre><code> 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
 （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。
</code></pre><p>HTML与XHTML——二者有什么区别</p>
<pre><code>区别：
1.所有的标记都必须要有一个相应的结束标记
2.所有标签的元素和属性的名字都必须使用小写
3.所有的XML标记都必须合理嵌套
4.所有的属性必须用引号&quot;&quot;括起来
5.把所有&lt;和&amp;特殊符号用编码表示
6.给所有属性赋一个值
7.不要在注释内容中使“”
8.图片必须有说明文字
</code></pre><h3 id="常见兼容性问题"><a href="#常见兼容性问题" class="headerlink" title="常见兼容性问题"></a>常见兼容性问题</h3><pre><code>* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.

* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

* 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了marginleft或marginright，margin值会加倍。）
  #box{ float:left; width:10px; margin:0 0 0 100px;}

 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

*  渐进识别的方式，从总体中逐渐排除局部。

  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

  css
      .bb{
       backgroundcolor:#f1ee18;/*所有识别*/
      .backgroundcolor:#00deff\9; /*IE6、7、8识别*/
      +backgroundcolor:#a200ff;/*IE6、7识别*/
      _backgroundcolor:#1e0bd1;/*IE6识别*/
      }

*  IE下,可以使用获取常规属性的方法来获取自定义属性,
   也可以使用getAttribute()获取自定义属性;
   Firefox下,只能使用getAttribute()获取自定义属性.
   解决方法:统一通过getAttribute()获取自定义属性.

* IE下,event对象有x,y属性,但是没有pageX,pageY属性;
  Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.

* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
  可通过加入 CSS 属性 webkittextsizeadjust: none; 解决.

* 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
LVHA :  a:link {} a:visited {} a:hover {} a:active {}

* 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用[html5](http://www.w3.org/TR/html5/singlepage.html)推荐的写法：`&lt;doctype html&gt;`

* 上下margin重合问题
ie和ff都存在，相邻的两个div的marginleft和marginright不会重合，但是margintop和marginbottom却会发生重合。
解决方法，养成良好的代码编写习惯，同时采用margintop或者同时采用marginbottom。
* ie6对png图片格式支持不好(引用一段脚本处理)
</code></pre><h3 id="解释下浮动和它的工作原理？清除浮动的技巧"><a href="#解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧"></a>解释下浮动和它的工作原理？清除浮动的技巧</h3><pre><code>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

1.使用空标签清除浮动。
   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。
2.使用overflow。
   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。
3.使用after伪对象清除浮动。
   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
</code></pre><h3 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h3><pre><code>浮动元素引起的问题：
（1）父元素的高度无法被撑开，影响与父元素同级的元素
（2）与浮动元素同级的非浮动元素会跟随其后
（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
</code></pre><p>解决方法：<br>使用<code>CSS</code>中的<code>clear:both</code>;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加<code>clearfix</code>样式：</p>
<pre><code>.clearfix:after{content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;}
.clearfix{display: inlineblock;} /* for IE/Mac */
</code></pre><p><strong>清除浮动的几种方法：</strong></p>
<pre><code>1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
2，使用after伪类

#parent:after{
    content:&quot;.&quot;;
    height:0;
    visibility:hidden;
    display:block;
    clear:both;
    }

3,浮动外部元素
4,设置`overflow`为`hidden`或者auto
</code></pre><h3 id="IE-8以下版本的浏览器中的盒模型有什么不同"><a href="#IE-8以下版本的浏览器中的盒模型有什么不同" class="headerlink" title="IE 8以下版本的浏览器中的盒模型有什么不同"></a>IE 8以下版本的浏览器中的盒模型有什么不同</h3><pre><code>IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框
</code></pre><h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点。" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点。"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h3><pre><code>（1）创建新节点

      createDocumentFragment()    //创建一个DOM片段

      createElement()   //创建一个具体的元素

      createTextNode()   //创建一个文本节点

（2）添加、移除、替换、插入

      appendChild()

      removeChild()

      replaceChild()

      insertBefore() //在已有的子节点前插入一个新的子节点

（3）查找

      getElementsByTagName()    //通过标签名称

      getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)

      getElementById()    //通过元素Id，唯一性
</code></pre><h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><pre><code>* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

* 拖拽释放(Drag and drop) API
  语义化更好的内容标签（header,nav,footer,aside,article,section）
  音频、视频API(audio,video)
  画布(Canvas) API
  地理(Geolocation) API
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
  sessionStorage 的数据在浏览器关闭后自动删除

  表单控件，calendar、date、time、email、url、search
  新的技术webworker, websocket, Geolocation

* 移除的元素

纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；

支持HTML5新标签：

* IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，

  浏览器支持新标签后，还需要添加标签默认的样式：

* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   &lt;![if lt IE 9]&gt;
   &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
   &lt;![endif]&gt;
如何区分： DOCTYPE声明\新增的结构元素\功能元素
</code></pre><h3 id="iframe的优缺点？"><a href="#iframe的优缺点？" class="headerlink" title="iframe的优缺点？"></a>iframe的优缺点？</h3><pre><code>1.&lt;iframe&gt;优点：

    解决加载缓慢的第三方内容如图标和广告等的加载问题
    Security sandbox
    并行加载脚本

2.&lt;iframe&gt;的缺点：


    *iframe会阻塞主页面的Onload事件；

    *即时内容为空，加载也需要时间
    *没有语意
</code></pre><h3 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h3><pre><code>调用localstorge、cookies等本地存储方式
</code></pre><h3 id="webSocket如何兼容低浏览器？"><a href="#webSocket如何兼容低浏览器？" class="headerlink" title="webSocket如何兼容低浏览器？"></a>webSocket如何兼容低浏览器？</h3><pre><code>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR
</code></pre><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><pre><code>一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
</code></pre><h3 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a>你如何对网站的文件和资源进行优化？</h3><pre><code>期待的解决方案包括：
 文件合并
 文件最小化/文件压缩
 使用 CDN 托管
 缓存的使用（多个域名来提供缓存）
 其他
</code></pre><h3 id="请说出三种减少页面加载时间的方法。"><a href="#请说出三种减少页面加载时间的方法。" class="headerlink" title="请说出三种减少页面加载时间的方法。"></a>请说出三种减少页面加载时间的方法。</h3><pre><code> 1.优化图片
 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）
 3.优化CSS（压缩合并css，如margintop,marginleft...)
 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）
 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。
当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）

6.减少http请求（合并文件，合并图片）。
</code></pre><h3 id="你都使用哪些工具来测试代码的性能？"><a href="#你都使用哪些工具来测试代码的性能？" class="headerlink" title="你都使用哪些工具来测试代码的性能？"></a>你都使用哪些工具来测试代码的性能？</h3><pre><code>Profiler, JSPerf（http://jsperf.com/nexttickvssetzerotimeoutvssettimeout）, Dromaeo
</code></pre><h3 id="什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h3><pre><code> FOUC  Flash Of Unstyled Content 文档样式闪烁
 &lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;
而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。
 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。
</code></pre><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p><code>null</code>是一个表示”无”的对象，转为数值时为0；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>。</p>
<p>当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。<br><code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<pre><code>（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。
</code></pre><p><code>null</code>表示”没有对象”，即该处不应该有值。典型用法是：</p>
<pre><code>（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。
</code></pre><h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><pre><code>   1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
   2、属性和方法被加入到 this 引用的对象中。
   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre><h3 id="JSON-的了解？"><a href="#JSON-的了解？" class="headerlink" title="JSON 的了解？"></a>JSON 的了解？</h3><pre><code>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
{&apos;age&apos;:&apos;12&apos;, &apos;name&apos;:&apos;back&apos;}
</code></pre><h3 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><pre><code>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js
</code></pre><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题?"></a>如何解决跨域问题?</h3><pre><code>    jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面

jsonp的原理是动态插入script标签
</code></pre><p>具体参见：[详解js跨域问题][2]</p>
<h3 id="documen-write和-innerHTML的区别"><a href="#documen-write和-innerHTML的区别" class="headerlink" title="documen.write和 innerHTML的区别"></a>documen.write和 innerHTML的区别</h3><pre><code>document.write只能重绘整个页面

innerHTML可以重绘页面的一部分
</code></pre><h3 id="call-和-apply-的区别和作用？"><a href="#call-和-apply-的区别和作用？" class="headerlink" title=".call() 和 .apply() 的区别和作用？"></a>.call() 和 .apply() 的区别和作用？</h3><p>作用：动态改变某个类的某个方法的运行环境。<br>区别参见：[JavaScript学习总结（四）function函数部分][3]</p>
<h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><pre><code>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</code></pre><p>详见：[详解js变量、作用域及内存][4]</p>
<h3 id="JavaScript中的作用域与变量声明提升？"><a href="#JavaScript中的作用域与变量声明提升？" class="headerlink" title="JavaScript中的作用域与变量声明提升？"></a>JavaScript中的作用域与变量声明提升？</h3><p>详见：[详解JavaScript函数模式][5]</p>
<h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><pre><code>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中
</code></pre><h1 id="Javascript综合"><a href="#Javascript综合" class="headerlink" title="Javascript综合"></a>Javascript综合</h1><h3 id="你有哪些性能优化的方法？"><a href="#你有哪些性能优化的方法？" class="headerlink" title="你有哪些性能优化的方法？"></a>你有哪些性能优化的方法？</h3><p> （[详情请看雅虎14条性能优化原则][7]）。</p>
<pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

（4） 当需要设置的样式很多时设置className而不是直接操作style。

（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
</code></pre><h3 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h3><pre><code>100199 用于指定客户端应相应的某些动作。
200299 用于表示请求成功。
300399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。
400499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。
500599 用于支持服务器错误。 503 – 服务不可用
</code></pre><p>详情：<a href="http://segmentfault.com/blog/trigkit4/1190000000691919" target="_blank" rel="external">http://segmentfault.com/blog/trigkit4/1190000000691919</a></p>
<h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><pre><code>    分为4个步骤：
    （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。
    （2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
    （3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。
    （4），此时，Web服务器提供资源服务，客户端开始下载资源。

请求返回后，便进入了我们关注的前端模块
简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM
</code></pre><p>详情：[从输入 URL 到浏览器接收的过程中发生了什么事情？][8]</p>
<h3 id="平时如何管理你的项目？"><a href="#平时如何管理你的项目？" class="headerlink" title="平时如何管理你的项目？"></a>平时如何管理你的项目？</h3><pre><code>先期团队必须确定好全局样式（globe.css），编码模式(utf8) 等；

        编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

        标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

        页面进行标注（例如 页面 模块 开始和结束）；

        CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；

        JS 分文件夹存放 命名以该JS功能为准的英文翻译。

        图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理
</code></pre><h3 id="说说最近最流行的一些东西吧？常去哪些网站？"><a href="#说说最近最流行的一些东西吧？常去哪些网站？" class="headerlink" title="说说最近最流行的一些东西吧？常去哪些网站？"></a>说说最近最流行的一些东西吧？常去哪些网站？</h3><pre><code>Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。
网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等
</code></pre><h3 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h3><pre><code>1，工厂模式
2，构造函数模式
3，原型模式
4，混合构造函数和原型模式
5，动态原型模式
6，寄生构造函数模式
7，稳妥构造函数模式
</code></pre><h3 id="javascript继承的6种方法"><a href="#javascript继承的6种方法" class="headerlink" title="javascript继承的6种方法"></a>javascript继承的6种方法</h3><pre><code>1，原型链继承
2，借用构造函数继承
3，组合继承(原型+借用构造)
4，原型式继承
5，寄生式继承
6，寄生组合式继承
</code></pre><p>详情：[JavaScript继承方式详解][9]</p>
<h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><pre><code>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.
</code></pre><p>详情：[JavaScript学习总结（七）Ajax和Http状态字][10]</p>
<h3 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h3><pre><code>1.异步加载的方案： 动态插入script标签
2.通过ajax去获取js代码，然后通过eval执行
3.script标签上添加defer或者async属性
4.创建并插入iframe，让它异步执行js
5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
</code></pre><h3 id="前端安全问题？"><a href="#前端安全问题？" class="headerlink" title="前端安全问题？"></a>前端安全问题？</h3><pre><code>    （XSS，sql注入，CSRF）
CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。

**完成CSRF需要两个步骤：**

1.登陆受信任的网站A，在本地生成COOKIE

2.在不登出A的情况下，或者本地COOKIE没有过期的情况下，访问危险网站B。
</code></pre><h3 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h3><pre><code>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个

Firefox，chrome也是6个
</code></pre><h3 id="javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h3><pre><code>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量
</code></pre><h3 id="grunt，-YUI-compressor-和-google-clojure用来进行代码压缩的用法。"><a href="#grunt，-YUI-compressor-和-google-clojure用来进行代码压缩的用法。" class="headerlink" title="grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。"></a>grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。</h3><pre><code>YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。

使用方法：

//压缩JS
java jar yuicompressor2.4.2.jar type js charset utf8 v src.js &gt; packed.js
//压缩CSS
java jar yuicompressor2.4.2.jar type css charset utf8 v src.css &gt; packed.css
</code></pre><p>详情请见：[你需要掌握的前端代码性能优化工具][11]</p>
<h3 id="Flash、Ajax各自的优缺点，在使用中如何取舍？"><a href="#Flash、Ajax各自的优缺点，在使用中如何取舍？" class="headerlink" title="Flash、Ajax各自的优缺点，在使用中如何取舍？"></a>Flash、Ajax各自的优缺点，在使用中如何取舍？</h3><pre><code>1、Flash ajax对比
Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。
Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
</code></pre><h3 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h3><p>概念:同源策略是客户端脚本（尤其是<code>Javascript</code>）的重要的安全度量标准。它最早出自<code>Netscape Navigator2.0</code>，其目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="为什么要有同源限制？"><a href="#为什么要有同源限制？" class="headerlink" title="为什么要有同源限制？"></a>为什么要有同源限制？</h3><p>   我们举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<h3 id="什么是-“use-strict”-使用它的好处和坏处分别是什么？"><a href="#什么是-“use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="什么是 “use strict”; ? 使用它的好处和坏处分别是什么？"></a>什么是 “use strict”; ? 使用它的好处和坏处分别是什么？</h3><p><code>ECMAscript 5</code>添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得<code>Javascript</code>在更严格的条件下运行。</p>
<p>设立”严格模式”的目的，主要有以下几个：</p>
<pre><code>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
消除代码运行的一些不安全之处，保证代码运行的安全；
提高编译器效率，增加运行速度；
为未来新版本的Javascript做好铺垫。
</code></pre><p>注：经过测试<code>IE6,7,8,9</code>均不支持严格模式。</p>
<p>缺点：<br>现在网站的<code>JS</code> 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 <code>merge</code> 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h3 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h3><pre><code>    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：
无法使用缓存文件（更新服务器上的文件或数据库）
向服务器发送大量数据（POST 没有数据量限制）
发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
</code></pre><h3 id="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"><a href="#哪些地方会出现css阻塞，哪些地方会出现js阻塞？" class="headerlink" title="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"></a>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><p><strong>js的阻塞特性：</strong>所有浏览器在下载<code>JS</code>的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到<code>JS</code>下载、解析、执行完毕后才开始继续<code>并行下载</code>其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载<code>JS</code>，但是<code>JS</code>下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。</p>
<p>由于浏览器为了防止出现<code>JS</code>修改<code>DOM</code>树，需要重新构建<code>DOM</code>树的情况，所以就会阻塞其他的下载和呈现。</p>
<p>嵌入<code>JS</code>会阻塞所有内容的呈现，而外部<code>JS</code>只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p>
<p><code>CSS</code>怎么会阻塞加载了？<code>CSS</code>本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，<code>IE6</code>下<code>CSS</code>都是阻塞加载）</p>
<p>当<code>CSS</code>后面跟着嵌入的<code>JS</code>的时候，该<code>CSS</code>就会出现阻塞后面资源下载的情况。而当把嵌入<code>JS</code>放到<code>CSS</code>前面，就不会出现阻塞的情况了。</p>
<p> 根本原因：因为浏览器会维持<code>html</code>中<code>css</code>和<code>js</code>的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的<code>JS</code>会阻塞后面的资源加载，所以就会出现上面<code>CSS</code>阻塞下载的情况。</p>
<h3 id="嵌入JS应该放在什么位置？"><a href="#嵌入JS应该放在什么位置？" class="headerlink" title="嵌入JS应该放在什么位置？"></a>嵌入<code>JS</code>应该放在什么位置？</h3><pre><code>1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。

2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。

3、使用defer（只支持IE）

4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用`setTimeout`来调用
</code></pre><h3 id="Javascript无阻塞加载具体方式"><a href="#Javascript无阻塞加载具体方式" class="headerlink" title="Javascript无阻塞加载具体方式"></a>Javascript无阻塞加载具体方式</h3><p>  <strong>将脚本放在底部。</strong><code>&lt;link&gt;</code>还是放在<code>head</code>中，用以保证在<code>js</code>加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。<br>  <strong>成组脚本</strong>：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。</p>
<p>  <strong>非阻塞脚本</strong>：等页面完成加载后，再加载<code>js</code>代码。也就是，在<code>window.onload</code>事件发出后开始下载代码。<br>    （1）<code>defer</code>属性：支持IE4和<code>fierfox3.5</code>更高版本浏览器<br>    （2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建<code>HTML</code>的几乎全部文档内容。代码如下：</p>
<p><br></p>
<pre><code>&lt;script&gt;
var script=document.createElement(&quot;script&quot;);
script.type=&quot;text/javascript&quot;;
script.src=&quot;file.js&quot;;
document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);
&lt;/script&gt;
</code></pre><p> 此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。</p>
<h3 id="闭包相关问题？"><a href="#闭包相关问题？" class="headerlink" title="闭包相关问题？"></a>闭包相关问题？</h3><p>详情请见：[详解js闭包][12]</p>
<h3 id="js事件处理程序问题？"><a href="#js事件处理程序问题？" class="headerlink" title="js事件处理程序问题？"></a>js事件处理程序问题？</h3><p>详情请见：[JavaScript学习总结（九）事件详解][13]</p>
<h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><pre><code>它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
</code></pre><h3 id="写一个通用的事件侦听器函数"><a href="#写一个通用的事件侦听器函数" class="headerlink" title="写一个通用的事件侦听器函数?"></a>写一个通用的事件侦听器函数?</h3><pre><code>// event(事件)工具集，来源：github.com/markyun
    markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
            if (fn==null) {
                fn=document;
            }
            var oldonload = window.onload;
            if (typeof window.onload != &apos;function&apos;) {
                window.onload = fn;
            } else {
                window.onload = function() {
                    oldonload();
                    fn();
                };
            }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
            if (element.addEventListener) {
                //事件类型、需要执行的函数、是否捕捉
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent(&apos;on&apos; + type, function() {
                    handler.call(element);
                });
            } else {
                element[&apos;on&apos; + type] = handler;
            }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
            if (element.removeEnentListener) {
                element.removeEnentListener(type, handler, false);
            } else if (element.datachEvent) {
                element.detachEvent(&apos;on&apos; + type, handler);
            } else {
                element[&apos;on&apos; + type] = null;
            }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else {
                ev.cancelBubble = true;
            }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // 获取事件目标
        getTarget : function(event) {
            return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
            var ev = e || window.event;
            if (!ev) {
                var c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev &amp;&amp; Event == ev.constructor) {
                        break;
                    }
                    c = c.caller;
                }
            }
            return ev;
        }
    };
</code></pre><h3 id="Node-js的适用场景？"><a href="#Node-js的适用场景？" class="headerlink" title="Node.js的适用场景？"></a>Node.js的适用场景？</h3><pre><code>高并发、聊天、实时消息推送
</code></pre><h3 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h3><pre><code>*  原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
*  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
</code></pre><h3 id="页面重构怎么操作？"><a href="#页面重构怎么操作？" class="headerlink" title="页面重构怎么操作？"></a>页面重构怎么操作？</h3><pre><code>编写 CSS、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。
</code></pre><h3 id="WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><pre><code>html5 websoket
    WebSocket通过Flash
    XHR长时间连接
    XHR Multipart Streaming
    不可见的Iframe
    &lt;script&gt;标签的长时间连接(可跨域)
</code></pre><h3 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；
3.  ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true;
</code></pre><h3 id="ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><a href="#ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题" class="headerlink" title="ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?"></a>ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h3><p>详情请见：[JavaScript学习总结（七）Ajax和Http状态字][14]</p>
<pre><code>1. 通过异步模式，提升了用户体验

  2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用

  3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

  2. Ajax的最大的特点是什么。

  Ajax可以实现动态不刷新（局部刷新）
  readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成

ajax的缺点

  1、ajax不支持浏览器back按钮。

  2、安全问题 AJAX暴露了与服务器交互的细节。

  3、对搜索引擎的支持比较弱。

  4、破坏了程序的异常机制。

  5、不容易调试。

跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面
</code></pre><h3 id="js对象的深度克隆"><a href="#js对象的深度克隆" class="headerlink" title="js对象的深度克隆"></a>js对象的深度克隆</h3><pre><code>function clone(Obj) {
      var buf;
      if (Obj instanceof Array) {
          buf = [];  //创建一个空的数组
          var i = Obj.length;
          while (i) {
              buf[i] = clone(Obj[i]);
          }
          return buf;
      }else if (Obj instanceof Object){
          buf = {};  //创建一个空对象
          for (var k in Obj) {  //为这个对象添加新的属性
              buf[k] = clone(Obj[k]);
          }
          return buf;
      }else{
          return Obj;
      }
  }
</code></pre><h3 id="AMD和CMD-规范的区别？"><a href="#AMD和CMD-规范的区别？" class="headerlink" title="AMD和CMD 规范的区别？"></a>AMD和CMD 规范的区别？</h3><p>详情请见：[详解JavaScript模块化开发][15]</p>
<h3 id="网站重构的理解？"><a href="#网站重构的理解？" class="headerlink" title="网站重构的理解？"></a>网站重构的理解？</h3><pre><code>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。

对于传统的网站来说重构通常是：

表格(table)布局改为DIV+CSS
使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)
对于移动平台的优化
针对于SEO进行优化
深层次的网站重构应该考虑的方面

减少代码间的耦合
让代码保持弹性
严格按规范编写代码
设计可扩展的API
代替旧有的框架、语言(如VB)
增强用户体验
通常来说对于速度的优化也包含在重构中

压缩JS、CSS、image等前端资源(通常是由服务器来解决)
程序的性能优化(如数据读写)
采用CDN来加速资源加载
对于JS DOM的优化
HTTP服务器的文件缓存
</code></pre><h3 id="如何获取UA？"><a href="#如何获取UA？" class="headerlink" title="如何获取UA？"></a>如何获取UA？</h3><pre><code>&lt;script&gt;
    function whatBrowser() {
        document.Browser.Name.value=navigator.appName;
        document.Browser.Version.value=navigator.appVersion;
        document.Browser.Code.value=navigator.appCodeName;
        document.Browser.Agent.value=navigator.userAgent;
    }
&lt;/script&gt;
</code></pre><h3 id="js数组去重"><a href="#js数组去重" class="headerlink" title="js数组去重"></a>js数组去重</h3><p>以下是数组去重的三种方法：</p>
<pre><code>Array.prototype.unique1 = function () {
  var n = []; //一个新的临时数组
  for (var i = 0; i &lt; this.length; i++) //遍历当前数组
  {
    //如果当前数组的第i已经保存进了临时数组，那么跳过，
    //否则把当前项push到临时数组里面
    if (n.indexOf(this[i]) == 1) n.push(this[i]);
  }
  return n;
}

Array.prototype.unique2 = function()
{
    var n = {},r=[]; //n为hash表，r为临时数组
    for(var i = 0; i &lt; this.length; i++) //遍历当前数组
    {
        if (!n[this[i]]) //如果hash表中没有当前项
        {
            n[this[i]] = true; //存入hash表
            r.push(this[i]); //把当前数组的当前项push到临时数组里面
        }
    }
    return r;
}

Array.prototype.unique3 = function()
{
    var n = [this[0]]; //结果数组
    for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历
    {
        //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
        //那么表示第i项是重复的，忽略掉。否则存入结果数组
        if (this.indexOf(this[i]) == i) n.push(this[i]);
    }
    return n;
}
</code></pre><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><pre><code>100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK   正常返回信息
201  Created  请求成功并且服务器创建了新的资源
202  Accepted  服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302 Found  临时性重定向。
303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified  自从上次请求后，请求的网页未修改过。

400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized  请求未授权。
403 Forbidden  禁止访问。
404 Not Found  找不到如何与 URI 相匹配的资源。

500 Internal Server Error  最常见的服务器端错误。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
</code></pre><h3 id="cachecontrol"><a href="#cachecontrol" class="headerlink" title="cachecontrol"></a>cachecontrol</h3><p>网页的缓存是由HTTP消息头中的<code>“Cachecontrol”</code>来控制的，常见的取值有<code>private、nocache、maxage、mustrevalidate</code>等，默认为<code>private</code>。</p>
<p><code>Expires</code> 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户端在这个时间之前不去检查（发请求），等同<code>maxage</code>的效果。但是如果同时存在，则被<code>CacheControl</code>的<code>maxage</code>覆盖。</p>
<pre><code>Expires = &quot;Expires&quot; &quot;:&quot; HTTPdate
</code></pre><p>例如</p>
<pre><code>Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是GMT格式）
</code></pre><p>如果把它设置为<code>1</code>，则表示立即过期</p>
<p><code>Expires</code>和<code>maxage</code>都可以用来指定文档的过期时间，但是二者有一些细微差别</p>
<pre><code>1.Expires在HTTP/1.0中已经定义，CacheControl:maxage在HTTP/1.1中才有定义，为了向下兼容，仅使用maxage不够；
2.Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：1)客户端和服务器时间不同步导致Expires的配置出现问题。 2）很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象；

3.maxage 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s),相对的是文档第一次被请求时服务器记录的Request_time(请求时间)

4.Expires指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime),而maxage相对对的是文档的请求时间(Atime)

如果值为nocache,那么每次都会访问服务器。如果值为maxage,则在过期之前不会重复访问服务器。
</code></pre><h3 id="js操作获取和设置cookie"><a href="#js操作获取和设置cookie" class="headerlink" title="js操作获取和设置cookie"></a>js操作获取和设置cookie</h3><pre><code>//创建cookie
function setCookie(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value);
    if (expires instanceof Date) {
        cookieText += &apos;; expires=&apos; + expires;
    }
    if (path) {
        cookieText += &apos;; expires=&apos; + expires;
    }
    if (domain) {
        cookieText += &apos;; domain=&apos; + domain;
    }
    if (secure) {
        cookieText += &apos;; secure&apos;;
    }
    document.cookie = cookieText;
}

//获取cookie
function getCookie(name) {
    var cookieName = encodeURIComponent(name) + &apos;=&apos;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieValue = null;
    if (cookieStart &gt; 1) {
        var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);
        if (cookieEnd == 1) {
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
    }
    return cookieValue;
}

//删除cookie
function unsetCookie(name) {
    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);
}
</code></pre><h3 id="请你谈谈Cookie的弊端"><a href="#请你谈谈Cookie的弊端" class="headerlink" title="请你谈谈Cookie的弊端"></a>请你谈谈Cookie的弊端</h3><p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br>第一：每个特定的域名下最多生成20个<code>cookie</code></p>
<pre><code>1.IE6或更低版本最多20个cookie
2.IE7和之后的版本最后可以有50个cookie。
3.Firefox最多50个cookie
4.chrome和Safari没有做硬性限制
</code></pre><p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>uerData</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<h3 id="优点：极高的扩展性和可用性"><a href="#优点：极高的扩展性和可用性" class="headerlink" title="优点：极高的扩展性和可用性"></a>优点：极高的扩展性和可用性</h3><pre><code>1.通过良好的编程，控制保存在cookie中的session对象的大小。
2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
</code></pre><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><pre><code>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。

2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h3><p>在较高版本的浏览器中，<code>js</code>提供了<code>sessionStorage</code>和<code>globalStorage</code>。在<code>HTML5</code>中提供了<code>localStorage</code>来取代<code>globalStorage</code>。</p>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h3><p><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽，另外<code>cookie</code>还需要指定作用域，不可以跨域调用。</p>
<p>除此之外，<code>Web Storage</code>拥有<code>setItem,getItem,removeItem,clear</code>等方法，不像<code>cookie</code>需要前端开发者自己封装<code>setCookie，getCookie</code>。</p>
<p>但是<code>Cookie</code>也是不可以或缺的：<code>Cookie</code>的作用是与服务器进行交互，作为<code>HTTP</code>规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生</p>
<p>浏览器的支持除了<code>IE７</code>及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的<code>UserData</code>其实就是<code>javascript</code>本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持<code>web storage</code>。</p>
<p><code>localStorage</code>和<code>sessionStorage</code>都具有相同的操作方法，例如<code>setItem、getItem</code>和<code>removeItem</code>等</p>
<h1 id="综合理解"><a href="#综合理解" class="headerlink" title="综合理解"></a>综合理解</h1><h3 id="你遇到过比较难的技术问题是？你是如何解决的？"><a href="#你遇到过比较难的技术问题是？你是如何解决的？" class="headerlink" title="你遇到过比较难的技术问题是？你是如何解决的？"></a>你遇到过比较难的技术问题是？你是如何解决的？</h3><h3 id="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"><a href="#常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？" class="headerlink" title="常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"></a>常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3><h3 id="列举IE-与其他浏览器不一样的特性？"><a href="#列举IE-与其他浏览器不一样的特性？" class="headerlink" title="列举IE 与其他浏览器不一样的特性？"></a>列举IE 与其他浏览器不一样的特性？</h3><h3 id="99-的网站都需要被重构是那本书上写的？"><a href="#99-的网站都需要被重构是那本书上写的？" class="headerlink" title="99%的网站都需要被重构是那本书上写的？"></a>99%的网站都需要被重构是那本书上写的？</h3><pre><code>* 网站重构：应用web标准进行设计（第2版）
</code></pre><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><pre><code>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.

渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
</code></pre><p>详见：[css学习归纳总结（一）][6]</p>
<h3 id="WEB应用从服务器主动推送Data到客户端有那些方式？-1"><a href="#WEB应用从服务器主动推送Data到客户端有那些方式？-1" class="headerlink" title="WEB应用从服务器主动推送Data到客户端有那些方式？"></a>WEB应用从服务器主动推送Data到客户端有那些方式？</h3><h3 id="对Node的优点和缺点提出了自己的看法？"><a href="#对Node的优点和缺点提出了自己的看法？" class="headerlink" title="对Node的优点和缺点提出了自己的看法？"></a>对Node的优点和缺点提出了自己的看法？</h3><pre><code>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
</code></pre><h3 id="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"><a href="#除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？" class="headerlink" title="除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"></a>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3><h3 id="你常用的开发工具是什么，为什么？"><a href="#你常用的开发工具是什么，为什么？" class="headerlink" title="你常用的开发工具是什么，为什么？"></a>你常用的开发工具是什么，为什么？</h3><h3 id="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><pre><code>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。
    1、实现界面交互
    2、提升用户体验
    3、有了Node.js，前端可以实现服务端的一些事情


前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，

 参与项目，快速高质量完成实现效果图，精确到1px；

 与团队成员，UI设计，产品经理的沟通；

 做好的页面结构，页面重构和用户体验；

 处理hack，兼容、写出优美的代码格式；

 针对服务器的优化、拥抱最新前端技术。
</code></pre><h3 id="你在现在的团队处于什么样的角色，起到了什么明显的作用？"><a href="#你在现在的团队处于什么样的角色，起到了什么明显的作用？" class="headerlink" title="你在现在的团队处于什么样的角色，起到了什么明显的作用？"></a>你在现在的团队处于什么样的角色，起到了什么明显的作用？</h3><h3 id="你认为怎样才是全端工程师（Full-Stack-developer）？"><a href="#你认为怎样才是全端工程师（Full-Stack-developer）？" class="headerlink" title="你认为怎样才是全端工程师（Full Stack developer）？"></a>你认为怎样才是全端工程师（Full Stack developer）？</h3><h3 id="介绍一个你最得意的作品吧？"><a href="#介绍一个你最得意的作品吧？" class="headerlink" title="介绍一个你最得意的作品吧？"></a>介绍一个你最得意的作品吧？</h3><h3 id="项目中遇到什么问题？如何解决？"><a href="#项目中遇到什么问题？如何解决？" class="headerlink" title="项目中遇到什么问题？如何解决？"></a>项目中遇到什么问题？如何解决？</h3><h3 id="你的优点是什么？缺点是什么？"><a href="#你的优点是什么？缺点是什么？" class="headerlink" title="你的优点是什么？缺点是什么？"></a>你的优点是什么？缺点是什么？</h3><h3 id="如何管理前端团队"><a href="#如何管理前端团队" class="headerlink" title="如何管理前端团队?"></a>如何管理前端团队?</h3><h3 id="最近在学什么？能谈谈你未来3，5年给自己的规划吗？"><a href="#最近在学什么？能谈谈你未来3，5年给自己的规划吗？" class="headerlink" title="最近在学什么？能谈谈你未来3，5年给自己的规划吗？"></a>最近在学什么？能谈谈你未来3，5年给自己的规划吗？</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2015年大前端技术年终总结]]></title>
      <url>http://pengfei6.github.io/2016/01/12/2015%E5%B9%B4%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="2015年大前端技术年终总结"><a href="#2015年大前端技术年终总结" class="headerlink" title="2015年大前端技术年终总结"></a>2015年大前端技术年终总结</h1><blockquote>
<p>数说前端技术，分类回顾点评。</p>
</blockquote>
<h2 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h2><h3 id="1-1-工具"><a href="#1-1-工具" class="headerlink" title="1.1 工具"></a>1.1 工具</h3><h4 id="1-1-1-构建工具"><a href="#1-1-1-构建工具" class="headerlink" title="1.1.1 构建工具"></a>1.1.1 构建工具</h4><ul>
<li>grunt </li>
<li>gulp </li>
<li>webpack </li>
<li>fis3 </li>
<li>coolie </li>
<li>jdf</li>
</ul>
<blockquote>
<p>精彩点评：<br><a id="more"></a></p>
</blockquote>
<h4 id="1-1-2-编译工具"><a href="#1-1-2-编译工具" class="headerlink" title="1.1.2 编译工具"></a>1.1.2 编译工具</h4><ul>
<li>babel </li>
<li>browserify</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h4 id="1-1-3-包管理工具"><a href="#1-1-3-包管理工具" class="headerlink" title="1.1.3 包管理工具"></a>1.1.3 包管理工具</h4><ul>
<li>npm </li>
<li>bower </li>
<li>component</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-2-前端类库和框架"><a href="#1-2-前端类库和框架" class="headerlink" title="1.2 前端类库和框架"></a>1.2 前端类库和框架</h3><h4 id="1-2-1-类库"><a href="#1-2-1-类库" class="headerlink" title="1.2.1 类库"></a>1.2.1 类库</h4><ul>
<li>jquery </li>
<li>zepto </li>
<li>underscore </li>
<li>react </li>
<li>redux/reflux/flux</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h4 id="1-2-2-mvc框架"><a href="#1-2-2-mvc框架" class="headerlink" title="1.2.2 mvc框架"></a>1.2.2 mvc框架</h4><ul>
<li>angular1.3 </li>
<li>angular2.0 </li>
<li>ember2.0</li>
<li>backbone</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h4 id="1-2-3-mvvm框架"><a href="#1-2-3-mvvm框架" class="headerlink" title="1.2.3 mvvm框架"></a>1.2.3 mvvm框架</h4><ul>
<li>vuejs</li>
<li>avalon </li>
<li>knockout</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h4 id="1-2-4-UI框架"><a href="#1-2-4-UI框架" class="headerlink" title="1.2.4 UI框架"></a>1.2.4 UI框架</h4><ul>
<li>bootstrap </li>
<li>senmaticui </li>
<li>amazeui </li>
<li>ionic </li>
<li>framework7 </li>
<li>materialui</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-3-设计风格"><a href="#1-3-设计风格" class="headerlink" title="1.3 设计风格"></a>1.3 设计风格</h3><ul>
<li>扁平化 </li>
<li>3D</li>
<li>material design</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-4-Js语言相关"><a href="#1-4-Js语言相关" class="headerlink" title="1.4 Js语言相关"></a>1.4 Js语言相关</h3><ul>
<li>es6 </li>
<li>es7 </li>
<li>typescript </li>
<li>coffeescript</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-5-css预处理器"><a href="#1-5-css预处理器" class="headerlink" title="1.5 css预处理器"></a>1.5 css预处理器</h3><ul>
<li>less </li>
<li>sass </li>
<li>stylus</li>
<li>postcss</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-6-模块化规范"><a href="#1-6-模块化规范" class="headerlink" title="1.6 模块化规范"></a>1.6 模块化规范</h3><ul>
<li>amd </li>
<li>cmd </li>
<li>commonjs </li>
<li>umd </li>
<li>es6 Module</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-7-测试"><a href="#1-7-测试" class="headerlink" title="1.7 测试"></a>1.7 测试</h3><ul>
<li>mocha </li>
<li>chai</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-8-响应式方案"><a href="#1-8-响应式方案" class="headerlink" title="1.8 响应式方案"></a>1.8 响应式方案</h3><ul>
<li>百分比 </li>
<li>media query</li>
<li>em和rem </li>
<li>lib-flexible </li>
<li>hotcss</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-9-编辑器和IDE"><a href="#1-9-编辑器和IDE" class="headerlink" title="1.9 编辑器和IDE"></a>1.9 编辑器和IDE</h3><ul>
<li>sublime </li>
<li>atom</li>
<li>webstorm</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="1-10-移动开发"><a href="#1-10-移动开发" class="headerlink" title="1.10 移动开发"></a>1.10 移动开发</h3><ul>
<li>html5 + css3</li>
<li>react-native</li>
<li>phonegap </li>
<li>meteor</li>
<li>Cordova</li>
<li>微信开发</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h2 id="2-Node相关"><a href="#2-Node相关" class="headerlink" title="2. Node相关"></a>2. Node相关</h2><h3 id="2-1-框架"><a href="#2-1-框架" class="headerlink" title="2.1 框架"></a>2.1 框架</h3><ul>
<li>express </li>
<li>koa </li>
<li>thinkjs</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
<h3 id="2-2-优秀第三方包"><a href="#2-2-优秀第三方包" class="headerlink" title="2.2 优秀第三方包"></a>2.2 优秀第三方包</h3><h3 id="2-3-数据库"><a href="#2-3-数据库" class="headerlink" title="2.3 数据库"></a>2.3 数据库</h3><ul>
<li>mongodb </li>
<li>mysql </li>
<li>redis </li>
<li>postgresql </li>
<li>redis </li>
<li>oracle</li>
</ul>
<blockquote>
<p>精彩点评：</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Generator 函数的含义与用法]]></title>
      <url>http://pengfei6.github.io/2015/06/08/Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>转载自<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="external">阮一峰博客</a></p>
<ul>
<li>以前异步编程的方法，大概有下面四种：<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
</li>
<li>异步编程的语法目标，就是怎样让它更像同步编程。</li>
</ul>
<h3 id="一、什么是异步？（省略。。。）"><a href="#一、什么是异步？（省略。。。）" class="headerlink" title="一、什么是异步？（省略。。。）"></a>一、什么是异步？（省略。。。）</h3><h3 id="二、回调函数的概念"><a href="#二、回调函数的概念" class="headerlink" title="二、回调函数的概念"></a>二、回调函数的概念</h3><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，<br>等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用”。读取文件进行处理，是这样写的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。<br>一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？<br>原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="三、Promise-为解决回调函数噩梦"><a href="#三、Promise-为解决回调函数噩梦" class="headerlink" title="三、Promise (为解决回调函数噩梦)"></a>三、Promise (为解决回调函数噩梦)</h3><p>Promise不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</div><div class="line"></div><div class="line">readFile(fileA)</div><div class="line">.then(function(data)&#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(function()&#123;</div><div class="line">  return readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(function(data)&#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(function(err) &#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。<br>Promise 提供 then 方法加载回调函数，catch方法捕捉执行过程中抛出的错误。<br>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。<br>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<h3 id="四、协程"><a href="#四、协程" class="headerlink" title="四、协程"></a>四、协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">第一步，协程A开始执行。</div><div class="line">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</div><div class="line">第三步，（一段时间后）协程B交还执行权。</div><div class="line">第四步，协程A恢复执行。</div></pre></td></tr></table></figure></p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。<br>举例来说，读取文件的协程写法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function asnycJob() &#123;</div><div class="line">  // ...其他代码</div><div class="line">  var f = yield readFile(fileA);</div><div class="line">  // ...其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。<br>它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="五、Generator函数的概念"><a href="#五、Generator函数的概念" class="headerlink" title="五、Generator函数的概念"></a>五、Generator函数的概念</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。<br>异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next() // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。<br>调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。<br>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。<br>value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="六、Generator-函数的数据交换和错误处理"><a href="#六、Generator-函数的数据交换和错误处理" class="headerlink" title="六、Generator 函数的数据交换和错误处理"></a>六、Generator 函数的数据交换和错误处理</h3><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。<br>除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。<br>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next(2) // &#123; value: 2, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。<br>第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。<br>因此，这一步的 value 属性，返回的就是2（变量 y 的值）。<br>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  try &#123;</div><div class="line">    var y = yield x + 2;</div><div class="line">  &#125; catch (e)&#123; </div><div class="line">    console.log(e);</div><div class="line">  &#125;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next();</div><div class="line">g.throw（&apos;出错了&apos;）;</div><div class="line">// 出错了</div></pre></td></tr></table></figure></p>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try … catch 代码块捕获。<br>这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="Generator-函数的用法"><a href="#Generator-函数的用法" class="headerlink" title="Generator 函数的用法"></a>Generator 函数的用法</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fetch = require(&apos;node-fetch&apos;);</div><div class="line">function* gen()&#123;</div><div class="line">  var url = &apos;https://api.github.com/users/github&apos;;</div><div class="line">  var result = yield fetch(url);</div><div class="line">  console.log(result.bio);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。<br>执行这段代码的方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var g = gen();</div><div class="line">var result = g.next();</div><div class="line">result.value.then(function(data)&#123;</div><div class="line">  return data.json();</div><div class="line">&#125;).then(function(data)&#123;</div><div class="line">  g.next(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个next 方法。<br>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。本系列的后面部分，就将介绍如何自动化异步任务的流程管理。<br>另外，本文对 Generator 函数的介绍很简单，详尽的教程请阅读我写的<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">《ECMAScript 6入门》</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象和数组]]></title>
      <url>http://pengfei6.github.io/2014/11/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="面-向-对-象-和-数-组"><a href="#面-向-对-象-和-数-组" class="headerlink" title="面 向 对 象 和 数 组"></a>面 向 对 象 和 数 组</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><h3 id="1-1-初识对象"><a href="#1-1-初识对象" class="headerlink" title="1.1 初识对象"></a>1.1 初识对象</h3><p>对象在JavaScript中是对数据类型的笼统的称呼，对象本身也是一种数据类型，在基础课程中讲了单一的值类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var n = 0;	//number类型</div><div class="line">var b = true;	//boolean类型</div><div class="line">var str = &apos;abc&apos;;	//string类型</div></pre></td></tr></table></figure>
<p>在Javasript中，一共有五种基本的数据类型（null，undefined，string，boolean，number），由于这几种简单的数据类型是按值传递，故而也可以称之为值类型数据。这类数据类型有一个共同的特点，就是它们都表示的是一个值。就是一个数据只表示了一个值，它对应的变量也是只保存了这一个值。就是说i=3这个表达式中，3就是一个单一的数，那么i也只保存了3这么一个值。<br><a id="more"></a></p>
<blockquote>
<p>注：null和undefined其实属性标识性的数据，归到值类型或对象类型都不是很准确。</p>
</blockquote>
<h3 id="1-2-数据发展"><a href="#1-2-数据发展" class="headerlink" title="1.2 数据发展"></a>1.2 数据发展</h3><p>但随着数据的复杂程度提高，单一的值类型已不能满足编程的需要，便产生了用单一的值类型数据（或复合数据）去描述的复合型数据，这个复合数据就是对象类型数据。为了方便工作，方便编程，有了复合型的数据类型，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">     name:&apos;rose&apos;,</div><div class="line">     age:22,</div><div class="line">     height:180,</div><div class="line">     write:function()&#123; console.log(&apos;i can program&apos;)&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上定义了一个简单的复合数据类型的变量，这个变量以键值对的方式来存储数据，由于复合数据类型是按引用传递的，也可以称之为引用类型（Object，Array，Date，RegExp，Function）。而ECMA-262使用专业术语词汇将对象定义为“无序属性的集合，其属性可以包含基本值、对象或者函数”，即通过键值对来描述对象的属性和方法。</p>
<p>可以知道，对象就是一种数据结构，用于将多种数据或功能（或叫函数或方法）组织在一起。其实对象类型的数据的意义不仅仅是把多个值组织在一起，更重要的这些集合在一起的值之间还有关联，并且这些值也是对这个对象数据的整体描述，即用数据来描述数据。<br>当然，也可以把obj看做是一个内存块，在内存块中又划分了若干个小内存块，用来存放obj的值，这种数据的存储方式也是需要注意理解的。</p>
<h3 id="1-3-对象的特点"><a href="#1-3-对象的特点" class="headerlink" title="1.3  对象的特点"></a>1.3  对象的特点</h3><ul>
<li>可以复合存值，存很多值；</li>
<li>键和值对本身是对obj的描述，这些不仅仅是数据了，是描述了obj这个完整的对象的特征；</li>
<li>不同的属性之间也是有关系的，有关联的。如：数组的length属性，数组也是对象类型的，用来描述属性的存值个数。属性之间也是有关联的。</li>
</ul>
<p>以上是面向对象编程的特点，在编程语言中，我们经常用对象的这种特点，来描述一个复合的完整数据，即通过数据来描述数据，这就是面向对象的基础，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var web_engineer = &#123;</div><div class="line">	name:&apos;&apos;,</div><div class="line">	age:30,</div><div class="line">	js:function()&#123; console.log(&apos;javascript&apos;)&#125;,</div><div class="line">	css:function()&#123; console.log(&apos;css&apos;)&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="1-4-遍历对象"><a href="#1-4-遍历对象" class="headerlink" title="1.4  遍历对象"></a>1.4  遍历对象</h3><p>遍历对象的值，用for…in：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var attr in web_engineer)&#123;</div><div class="line">	alert(attr);	//获取属性</div><div class="line">	alert(web_engineer[attr]);	//获取值</div><div class="line">	alert(web_engineer.attr);	//获取值的另一方式，性能好，但不够灵活</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以依次按顺序的输出属性及对应的属性值，这种以字符形式的对象遍历输出是没有兼容性问题的。需要注意的是，有一种情况会有兼容性问题—-以数字为属性，这种情况在chrome浏览器中遍历时会将属性为数字的值优先输出。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">	name:&apos;somebody&apos;,</div><div class="line">	age:22,</div><div class="line">	0:&apos;number1&apos;,</div><div class="line">	1:&apos;number2&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，这里的person1[0]不是数组值，它是一种类似于数组的对象结构，称为类数组，在后面会详细的说到。</p>
<h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2 面向对象"></a>2 面向对象</h2><p>加：什么是对象和面向对象，我们用社会生产中商品（物品）和生成商品的方式来解释<br>注：这里的模式，就是指生产方式，创建对象的方式，上课的时候，一定要理解好这个“模式”的概念。这里说的这些设计模式，叫“创建型设计模式”，是诸多的设计模式中的一种</p>
<h3 id="2-1-创建单一的一个对象"><a href="#2-1-创建单一的一个对象" class="headerlink" title="2.1 创建单一的一个对象"></a>2.1 创建单一的一个对象</h3><p> 在前端发展早期，公司若需要招聘前端工程师的话，需要对招聘的人才特点进行相应的描述，这时我们可以创建一个obj对象来描述前端工程师的特点，这种描述对象的方式就是对象直接量创建对象。一般地，当数据量比较小的时候，适合用对象直接量创建对象。但麻烦的是，如果需要招聘一万个前端人才，则每招聘一次就需要创建一个对象来描述一次，这样效率就不高了。<br>更形象地说，在5000年前，如果需要做一件虎皮大衣，那么首先需要先打个老虎取得虎皮作为原材料，再纯手工缝制，才能制作出一件纯正的虎皮大衣成品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//对象，物件，产品</div><div class="line">//虎皮大衣</div><div class="line">var shirt = &#123;</div><div class="line">	//手工，基于对象的方式</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>小结：显然，这种生产方式是很落后的。相应的，在js中创建对象数据类型也是这样的，纯粹的用对象直接量来单次的描述对象在编程中非常的不方便，需要改进这种创建对象数据类型的方式，工厂模式可以提高这种落后的“生产方式” 。<br>加：一个对象的设计模式，单例模式的作用</p>
<h3 id="2-2-批量生产对象的方式：工厂模式"><a href="#2-2-批量生产对象的方式：工厂模式" class="headerlink" title="2.2 批量生产对象的方式：工厂模式"></a>2.2 批量生产对象的方式：工厂模式</h3></blockquote>
<p>我们知道，一个面包工厂生产面包的流程和我们自己在家做面包的流程是一样的，在家手工制作面包的生产方式就是基于对象。不同的是，工厂里面将生产面包的流程进行了改进，可以批量地生产了。而工厂是对生产对象的流程的归纳，或者叫做封装，这是面向对象。所以原来叫基于对象，现在是面向对象。</p>
<p>面向对象和基于对象的区别：生产流程的升级，生产方式的改变。面向对象的就是生产对象（对象是物件或是产品）的方式改进了。同样地，在程序语言设计中，面向对象是一种更高效的生产数据的方式。</p>
<p>回到前面的例子，现在社会上需要很多前端工程师了，需要批量的招聘，需求量很大，但前端工程师人才数量不足，这就需要一个培养前端工程师的流程了，需要培训机构批量的培训出前端工程师：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function FE()&#123;//定义一个前端工程师的规范</div><div class="line">   var obj = &#123;&#125;;//这个注释会引起误解，去掉：生产原料</div><div class="line">   obj.name = &apos;&apos;;	//加工过程</div><div class="line">   obj.age = &apos;&apos;;</div><div class="line">   obj.writeCss = function()&#123; console.log(&apos;css&apos;)&#125;;</div><div class="line">   obj.writeJs = function()&#123; console.log(&apos;js&apos;)&#125;;</div><div class="line">   return obj;	//生产出来的产品</div><div class="line">&#125;</div><div class="line">var a = [];</div><div class="line">for(var i = 0;i&lt;30;i++)&#123;</div><div class="line">	a.push(FE(i));//按着这个规范，用循环批量创建</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在定义了一个培养前端工程师的方法，将方法循环30次，就表示生产出30个前端工程师了，这就是典型的通过工厂模式来创建对象。将这种具体的生产方式抽象出一个生产的流程方法，比如现在有很多羊毛，需要批量生产出很多羊毛衫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function factory(material)&#123;//定义一个生产的流程（或叫规范也行）</div><div class="line">	var obj = &#123;&#125;;</div><div class="line">	obj.material = meterial;//原料</div><div class="line">	obj.attr1 = &apos;&apos;;</div><div class="line">	obj.attr2 = &apos;&apos;;</div><div class="line">	obj.fn = function()&#123;&#125;;//比如羊毛衫还有自己的一些功能，则就是函           数型的属性了</div><div class="line">	return obj;//生产完成，出产品，不要忘了返回</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种抽象出的生产对象的方式就是工厂模式，这是一种简单的生产方式，是对原来手工生产羊毛衫的生产方式的改变，原来叫基于对象，现在就是面向对象了。所谓面向对象，就是指生产对象的方式。现在这是其中一种方式。</p>
<blockquote>
<p>小结：通过工厂模式，我们就可以大批量的生产物品了，但是有缺点，在商品短缺的年代，批量出来的可以畅销。但是当全世界都在生产，竞争加剧了，产品丰富了之后，就得提高品牌识别，贴牌了，加上商标，来加强竞争力。这就不能用简单的工厂模式了，需要将商品区别开来，提高产品的差异性。产品差异，在编程语言中叫实例识别，其实意思都是一样。产品差异的体现：同样是手机，苹果更贵小米就便宜；同样是汽车，宝马更贵而夏利就便宜。这种产品的差异性可以称之为实例识别。想要解决实例识别的问题则需要使用构造函数模式了。</p>
</blockquote>
<h3 id="2-3-有区别的批量生成对象：构造函数"><a href="#2-3-有区别的批量生成对象：构造函数" class="headerlink" title="2.3 有区别的批量生成对象：构造函数"></a>2.3 有区别的批量生成对象：构造函数</h3><p>以很有个性的360公司为模板，我们创建一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function FE360(name, age)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.writeCss = function()&#123;&#125;;</div><div class="line">	this.writeJs = function()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数和工厂模式对比：</p>
<ul>
<li>更简单了</li>
<li>少了对obj对象的定义，不用new Object</li>
<li>少了return，不需要返回值</li>
<li>用法也不一样了，有区别，现在不是直接运行了，需要new一个实例，用法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var person2 = new FE360(&apos;someone&apos;, 24);</div><div class="line">person2.age;</div><div class="line">person2.name;</div><div class="line">person2.writeCss();</div><div class="line">//这样就获得了有个性的360工程师的实例</div></pre></td></tr></table></figure>
<p>这里的person2不仅仅是一个对象，它还是构造函数FE360的一个实例，是属于类的实例了，FE360也不仅仅是一个普通函数了，而是构造函数了。现在可以继续创建不同的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person3 = new FE360(&apos;person3&apos;, 26);</div><div class="line">var person4 = new FE360(&apos;person4&apos;, 34);</div><div class="line">//这样用构造函数的方法就解决了实例的问题</div><div class="line">//Function的特殊性：一个方法是类还是函数，主要在于new的出现</div></pre></td></tr></table></figure>
<p>当new一个函数的时候，这个函数就是一个类。new的时候，浏览器的操作：</p>
<ol>
<li>首先会主动创建一个对象类型的数据，这个数据是当前函数的实例，或者说，以这个函数名为识别符的实例。可以用instanceof来检验一下：<br>alert(person2 instanceof FE360);</li>
<li>以这个实例为上下文（context，this，当前行为发生的那个主体），再把构造函数当成一个方法来运行，这个方法就是起一个初始化实例的作用</li>
<li>可以通过实例来使用构造函数的属性和方法了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function FE360(name, age)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.writeCss =function()&#123; alert(&apos;我叫&apos;+this.name+&apos;,我会写css&apos;); &#125;;</div><div class="line">	this.writeJs = function()&#123; alert(&apos;我叫&apos;+this.name+&apos;,我会写js&apos;); &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">person2.writeCss();</div><div class="line">person2.writeJs();</div></pre></td></tr></table></figure>
<blockquote>
<p>小结：对象本来是很笼统的概念，现在person2也是对象，但它是当前FE360的实例，这样就可以细分化了，这是对工厂模式的升级，是生产模式的改进，原来生产的都是一样的，现在可以将商品区分开来了。正如社会的发展，对社会角色的区分也越来越细化。</p>
</blockquote>
<ul>
<li>补充1：对象、类和实例的区分</li>
</ul>
<p>对象是万事万物，类是对万事万物的细分和区别，实例是类的具体化，再有什么功能或数据类型，再构造函数扩展就行。</p>
<ul>
<li>补充2：数据不单单是一个值，数据也有功能</li>
</ul>
<p>比如说，人就是一个抽象的值，不仅仅是一个信息的载体，还可以完成很多功能，比如：会上课会捣乱。数据的范围很广，也是一个数据体。Function类型的数据可以完成很多不同的功能。也就是说函数（function）也是数据。</p>
<p>少一个原型模式（prototype),一定要加上<br>不重复制造轮子的原则：原型模式</p>
<h3 id="2-4-兼顾以上二者的混合模式"><a href="#2-4-兼顾以上二者的混合模式" class="headerlink" title="2.4 兼顾以上二者的混合模式"></a>2.4 兼顾以上二者的混合模式</h3><blockquote>
<p>注：这里的模式，就是指生产方式，创建对象的方式。这里说的这些设计模式，叫“创建型设计模式”，是诸多的设计模式中的一种</p>
</blockquote>
<p>私有属性和共有属性。每一个实例上都会产生一个自己私有的属性和方法，比如说吃饭每个人都会，这是自己的私有属性，但这个功能是上帝就创造好的，不是后天培养创建的。构造函数模式虽然可以解决实例识别的问题，但本着编程的复用原则，构造函数模式却解决不了复用的问题，因为在构造函数内定义的方法是构造函数的私有属性，构造函数的实例之间无法去共享一个相同的方法。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person3.writeCss() == person4.writeCss);</div><div class="line">//这里alert出现的结果是false，说明这两个方法是不一样的。</div></pre></td></tr></table></figure>
<p>那怎么让不同的实例去共享相同的方法呢，Js的原型机制可以实现，这就是js面向对象的核心点。<br>下面使用创建对象的新模式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function FE360(name, age)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">//类的定义就发生了质的变化</div><div class="line">FE360.prototype.writeJs = function()&#123;</div><div class="line">    alert(&apos;我叫&apos;+this.name+&apos;,我会写js&apos;);</div><div class="line">&#125;;</div><div class="line">FE360.prototype.writeCss = function()&#123;</div><div class="line">     alert(&apos;我叫&apos;+this.name+&apos;,我会写css&apos;);</div><div class="line">&#125;;</div><div class="line">var person3 = new FE360(&apos;person3&apos;, 26);</div><div class="line">var person4 = new FE360(&apos;person4&apos;, 34);</div></pre></td></tr></table></figure>
<p>现在在原型上定义了需要共享的方法，而且只需要定义一次就可以了，此时在测试一下实例person3和person4调用的方法是否一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person3.writeCss() == person4.writeCss);	//弹出结果为true</div></pre></td></tr></table></figure></p>
<p>这说明person3和person4上的writeCss方法指向的是内存中的同一个地址，那么无论定义多少个实例，实例上用的方法都是一样的了。</p>
<p>原型是任何方法天生就有的属性，只有将方法当成一个类的时候，原型才有作用，把方法当成一个普通方法来运行的时候，原型也没什么用。现在将以上的例子来分解，演示原型的实现机制，如图1所示：</p>
<p>图 1 原型的实现机制<br> 创建完对象之后，对象是一个内存地址，没有运行之前，就有一个属性<strong>proto</strong>（这里是两个下划线，任何一个对象实例上都有这个属性），这个属性是天生的原型机制，会指向原型对象。而在person1中定义的name和age是它的私有属性，如果在私有作用域内找不到这两个属性，就会往原型对象逐级往上找。<br>把原型链展开来写，一定要把JS是基于原型继承的这一特点写清楚。尽量配上图。要求有图有真相</p>
<blockquote>
<p>总结：<br>加上：什么是模式，可以简单的理解为生成方式，以上解释过了。<br>1、面对对象的概念不是很深，这个思想不难理解，讲数组的时候可以体会到这个编程思想的用法。<br>2、工厂模式什么时候去使用，他的使用场合是在哪里，其实在编程过程中会接触到很多这个模式，比如说createElement，这就是一个典型的工厂方法。<br>3、使用什么样的模式，是按需求来决定。不必生搬硬套的去使用模式，应该自然而然的来使用，完全没有高低优劣之分。比如视频中说的富士康的工厂，他的生产模式就是代工，但是不能说它的生产方式就是低级，因为富士康的定位就是代工生产，生产的效率也很高。模式的使用在于编程的快捷需求，需求决定模式的选择。<br>4、Js不需要处理大批量的数据量，所以js的面向对象是灵活高效的，相对是比较瘦小的。但是由于js没有这种大数据量的特点，js就在浏览器中执行，标签较少，数据量较小。一切都是为灵活高效而服务的。比如说打一个蚊子，不需要飞机大炮，一个苍蝇拍就够了，这就是需求决定的。编程中使用标签多的时候也不会超过几千个，一个循环就可以了，所以没有必要过多的去强调面向对象。</p>
</blockquote>
<h2 id="3-数组基础"><a href="#3-数组基础" class="headerlink" title="3 数组基础"></a>3 数组基础</h2><h3 id="3-1-数组定义"><a href="#3-1-数组定义" class="headerlink" title="3.1 数组定义"></a>3.1 数组定义</h3><p>创建一个数组最简单的方式是数组直接量的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [0,1,2,3,4,5,6,7,8];</div><div class="line">console.log(arr1);	//5,6,7,8,9</div></pre></td></tr></table></figure></p>
<p>也可以用构造函数的方式来创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var arr=new Array(元素1，元素2….元素n)</div></pre></td></tr></table></figure></p>
<h3 id="3-2-数组方法"><a href="#3-2-数组方法" class="headerlink" title="3.2 数组方法"></a>3.2 数组方法</h3><p>数组有很多内置的强大方法，简单回顾一下：</p>
<h4 id="3-2-1-元素添加和删除"><a href="#3-2-1-元素添加和删除" class="headerlink" title="3.2.1 元素添加和删除"></a>3.2.1 元素添加和删除</h4><p>a) push()<br>该方法可向数组的末尾添加一个或是多个元素，并返回新的数组长度。可以这么来理解，push是对数据的压栈操作，栈不是什么很深的概念，不要被吓倒了，比如说，桌子上堆了厚厚的一摞书，压栈就是把书一本本的往上加，是不是很好理解。使用语法：arr.push(ele1，ele2…eleN)；其中，第一个参数是必填的，指要添加到数组的第一个元素，后面的参数可选，在使用过程中也一般只传第一个参数，在做遍历即可。<br>b) unshift()<br>该方法可向数组的开头添加一个或多个元素，并返回新的长度。它的作用不要和push方法混淆，一个是从数组的开头进行元素添加，一个是从数组的末尾进行元素的添加。使用语法：arr.unshift(ele1，ele2…eleN);<br>c) concat()<br>该方法用于连接两个或是多个数组，注意的是，该方法不会改变现有的数组，只是会返回一个被连接后的数组。使用语法：arr.concat(arr1，arr2…arrN);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [0,1,2,3,4,5,6,7,8];</div><div class="line">var arr2 = arr.concat([1,2,3], [22,33,44]);</div><div class="line">console.log(arr2);	//0,1,2,3,4,5,6,7,8,1,2,3,22,33,44</div></pre></td></tr></table></figure></p>
<p>d) pop()<br>该方法和push方法对应，但功能相反，用于删除并返回数组的最后一个元素，同时，数组的长度会被减1。如果数组已经为空，再去执行pop()方法，那么此时会返回undefined值。使用语法：arr.pop()，注意括号内不可传参数。<br>e) shift()<br>该方法和unshift方法对应，但功能相反，用于删除并返回数组的第一个元素。使用语法：arr.shift();</p>
<h4 id="3-2-2-slice和splice方法"><a href="#3-2-2-slice和splice方法" class="headerlink" title="3.2.2 slice和splice方法"></a>3.2.2 slice和splice方法</h4><p>a) slice()<br>该方法可以从已有的数组中返回规定的元素，此方法返回的是一个新数组，包含start到end（注意，不包含该元素）的arrObj数组中的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [0,1,2,3,4,5,6,7,8];</div><div class="line">var arr1 = arr.slice(5, 1);</div><div class="line">console.log(arr1);	//5,6,7,8,9</div></pre></td></tr></table></figure></p>
<p>使用语法：arr.slice(start, end)，其中参数start必填，它规定了开始选取元素的位置，但如果是负数的话，就是表示从数组的尾部开始算起的位置（-1为最后一个元素，-2为倒数第二个元素…）；参数end是选的，它规定了从何处结束选取，如果不传，则表示从规定的起始位置一直选取到结束，如果是负数，表示从数组的尾部开始算起的元素。在第四部分可以继续探讨slice方法的实现原理。<br>b) splice()<br>该方法功能很强大，可以用于对数组执行添加、删除和插入的功能，然后返回被删除的项目，该方法会改变原始的数组。<br>使用语法：arr.splice(index，count，item1，item2…itemN)；<br>参数说明：index是必填的参数，而且必须是整数，这个参数指定了添加或是删除项目的位置，而且index为负数时，表明可以从数组结尾处规定的位置执行该方法；count也是必填参数，指定要删除的项目数量，如果设置为0，则不删除项目，后面添加参数的话，此时就可实现插入的功能了；item是可选的参数，如果不传，则指向删除的功能，传入的话，可以实现添加和插入的功能<br>具体范例如下：<br>1).    插入功能(只插入)：splice(start, 0, args);//返回的是处理后的数组<br>2).    替换功能（删除和插入）：splice(start, delCount, args);//返回的是处理后的数组<br>3).    删除功能（只删除）：splice(start, delCount);//返回的是被删除的元素数组，若没有删除任何元素，则返回空数组</p>
<p>在开始了解这几个方法的时候，先普及一个重要的概念，即隐式调用和显式调用。其实这两个概念也很简单，所谓显式调用即是我们在编码的过程中主动的去调用该方法，而隐式调用则是js在处理过程中在进行某些数据类型转换时自动默认的调用该方法。那么为什么在这里提及隐式调用呢，由于toString()和valueOf()等方法属于原型对象都共有的方法，都会在需要的时候隐式的调用，完成相关的数据操作。</p>
<h4 id="3-2-3-toString方法"><a href="#3-2-3-toString方法" class="headerlink" title="3.2.3 toString方法"></a>3.2.3 toString方法</h4><p>    该方法用于将一个逻辑值转换成字符串，并返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var age = 123;</div><div class="line">var str = age.toString();//str结果为”123”</div><div class="line">var b = false;</div><div class="line">var bToString = b.toString();//bToString 结果为”false”</div></pre></td></tr></table></figure></p>
<p>    数值、布尔值、对象和字符串都有toString方法，但null和undefined值没有这个方法。<br>    toString在大多数情况下不需要传递参数，因为默认情况下该方法都是以十进制的格式返回数值的结果。如果传递参数给toString()的话则可以以二进制、八进制或十六进制表示的相应结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var num = 16;</div><div class="line">console.log(num.toString(2));//10000 二进制</div><div class="line">console.log(num.toString(8));//20 八进制</div><div class="line">console.log(num.toString(16));//10 十六进制</div><div class="line">console.log(num.toString(5));//31 虽然没有五进制，但是这样传参是可以被toString()方法接受的</div></pre></td></tr></table></figure></p>
<p>    没有重新定义toString方法，看看调用toString方法将Object类型转化成string类型是什么样的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;name:&quot;Tom&quot;, age:18&#125;;</div><div class="line">console.log(obj.toString());//&quot;[object Object]&quot;</div><div class="line">//此时调用的是从Object继承来的原始的toString()方法</div></pre></td></tr></table></figure></p>
<p>    toString方法的妙用—判断数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.call(null);//”[object Null]”</div><div class="line">Object.prototype.toString.call(undefined);//”[object Undefined]”</div><div class="line">Object.prototype.toString.call(“abc”);//”[object String]”</div><div class="line">Object.prototype.toString.call(123);//”[object Number]”</div><div class="line">Object.prototype.toString.call(true);//”[object Boolean]”</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;console.log(“test”);&#125;//函数类型</div><div class="line">Object.prototype.toString.call(fn);//”[object Function]”</div><div class="line">var arr = [1,2,3];//数组类型</div><div class="line">Object.prototype.toString.call(arr);//”[object Array]”</div></pre></td></tr></table></figure>
<h4 id="3-2-4-排序方法"><a href="#3-2-4-排序方法" class="headerlink" title="3.2.4 排序方法"></a>3.2.4 排序方法</h4><p>a) reverse()<br>该方法是用于颠倒数组中元素的顺序，需要注意的是，该方法直接在原数组上进行操作，会改变原数组，而不会创建一个新的数组，并且，使用时不需要传参，如：arr.reverse()。<br>b) sort()<br>该方法用于对数组的元素进行排序，和reverse方法类似，该方法也是直接在原数组上进行排序，会改变原数组。在这里，需要对该方法中的传参好好说明，调用该方法但不传参时，如arr.sort()，此时该方法将按ASCII码的字母顺序对数组中的元素进行排序，这是封装方法时这样设计的，使用时尤其应该注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [2,3,4,6,d,e,t,6];</div><div class="line">arr.sort();</div><div class="line">console.log(arr);</div></pre></td></tr></table></figure></p>
<p>如果需要按其他的标准进行排序时，可以将函数直接量作为该方法的传参，从而实现排序，如以下写法可以实现升序排序（对DOM元素排序，对对象的排序，用的排序的算法是插入排序的思）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var aNum = [33,22,67,3,543];</div><div class="line">aNum.sort(function(a, b)&#123;</div><div class="line">	console.log(aNum);</div><div class="line">	return a-b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>带单位增序降序的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var aNum = [&apos;33px&apos;,&apos;22px&apos;,&apos;67px&apos;,&apos;3px&apos;,&apos;543px&apos;];</div><div class="line">aNum.sort(function(a, b)&#123;</div><div class="line">	console.log(aNum);</div><div class="line">	return parseInt(a) - parseInt(b);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="3-2-5-数组转换"><a href="#3-2-5-数组转换" class="headerlink" title="3.2.5 数组转换"></a>3.2.5 数组转换</h4><p>a) toLocaleString()<br>toLocaleString()方法用于将数组转换为本地字符串，作用和toString差不多，但此方法是使用地区特定的分隔符来将生成的字符串连接起来。<br>b) valueOf()<br>该方法可以返回Array对象的原数值，通常都是在后台隐式的调用该方法，一般不会显式的出现我们的代码中。<br>c) join()<br>该方法用于将一个数组的所有元素都按指定的分隔符分隔，转换成字符串。<br>d) split()<br>该方法用于将字符串按片段分隔创建数组，和join()的功能正好相反。</p>
<h4 id="3-2-6-位置方法（ECMA5的方法）"><a href="#3-2-6-位置方法（ECMA5的方法）" class="headerlink" title="3.2.6 位置方法（ECMA5的方法）"></a>3.2.6 位置方法（ECMA5的方法）</h4><p>位置方法包括indexOf()和lastIndexOf()这两个方法用于搜索整个数组中具有给定值的元素，并且返回找到的第一个元素的索引值，如果没有找到，则返回-1。两者不同的是，indexOf方法是从头至尾的搜索，而lastIndexOf是从尾向前的搜索。<br>参数说明：indexOf()和lastIndexOf()方法的第一个参数都是必需的，传入的是需要搜索的目标值，而第二个参数是可选的，即指定开始搜索的位置，如果不传的话，indexOf()方法默认从头开始搜索，lastIndexOf方法默认从尾开始搜索。重要的是，第二个参数可以是一个负值，表示相对数组末尾的偏移量，所以这也使得以上两方法的使用没有特别明确的界限。</p>
<h4 id="3-2-7-迭代方法（ECMA5的方法）"><a href="#3-2-7-迭代方法（ECMA5的方法）" class="headerlink" title="3.2.7 迭代方法（ECMA5的方法）"></a>3.2.7 迭代方法（ECMA5的方法）</h4><p>在学习理解这五个迭代方法之前，我们来先模拟一下forEach()这个方法的实现，以便理解这些方法中用到的传参（这几个方法的形式参数都是一样的），这对后续学习很有帮忙，我们需要从根处模拟这些方法是用什么样的思路来封装的，好了，请看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Array.prototype.forEach=function(fun,context)&#123;</div><div class="line">	// forEach的实现原理</div><div class="line">	var len=this.length;</div><div class="line">	var context=arguments[1];//即使为undefined，call函数也正常运行。</div><div class="line">	if(typeof fun !==&quot;function&quot;)&#123;</div><div class="line">		throw &quot;输入正确函数!&quot;;</div><div class="line">	&#125;</div><div class="line">	for(var i=0;i&lt;len;i++)&#123;</div><div class="line">		fun.call(context,this[i],i,this);</div><div class="line">//注意这四个参数，很关键，context是上下文，即作用对象，this[i]是各项元素的值，i为各项的索引值，this为执行该方法的主体</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">arr.forEach(function(item,index,arr)&#123;</div><div class="line">	console.log(item,index,arr);</div><div class="line">	//item	   	arr的每一项的内容</div><div class="line">	//index	 各项的索引值</div><div class="line">	//arr	 	即是输入的原数组值</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>代码解析：审查以上代码，这是用原型的方法来模拟forEach的实现，forEach()方法中有两个传参，第一个fun（传入一个函数），第二个是context（上下文，可以理解为执行该方法的对象）。一般在使用过程中传入fun即可，在fun中自定义自己想要实现的功能。在fun中有三个传参，在代码中写的很清楚，请理解之。<br>a) every()<br>该方法对数组中的每一项都运行给定的函数直接量，如果该函数对每一项都返回true，则该方法返回true，注意是每一项都满足条件该方法才会返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3,4,5,6,7];</div><div class="line">var result=arr.every(function (item, index, array)&#123; return item&gt;5; &#125;);</div><div class="line">alert(result);	//此时会返回的结果是 false;</div><div class="line">var arr1=[3,4,5];</div><div class="line">var result1=arr1.every(function (item, index, array)&#123; return item&gt;2; &#125;);</div><div class="line">alert(result1);	//此时会返回的结果是 true;</div></pre></td></tr></table></figure></p>
<p>b) filter()<br>该方法对数组中的每一项都运行给定函数，返回该函数返回true的项组成的数组，从单词字面意思理解，该方法是对数据执行一个过滤的作用，满足条件的返回，不满足条件的丢弃，仅此而已，用个例子说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3,4,5,6,7];</div><div class="line">var result=arr.filter(function (item, index, array)&#123; return item&gt;5; &#125;);</div><div class="line">alert(result);	//此时会返回的结果是 [6,7];</div></pre></td></tr></table></figure></p>
<p>c) forEach<br>对数组中的每一项运行给定函数，需要注意的是，这个方法没有返回值。在编码的过程中使用这个方法会带来很多便利，因为该方法就有一个遍历数组元素的作用，不用每次的写一个for循环来获取数组的每一项进行操作了。<br>d) map()<br>对数组中的每一项运行给定的函数，返回每次函数调用的结果组成的数组，注意哦，这里返回的可是数组，和some()等方法返回布尔值不一样，使用过程中需要区别。<br>e) some()<br>对数组中的每一项运行给定的函数，如果该函数对任一项都返回true，则该方法返回true，和every()方法有点相似，但是要区别啊亲，简单区别的话可以从单词下手，every()是传入的函数需要对每一项都需要满足条件，该方法次啊会返回true；而some()方法是只要传入的函数对数组中的某一项返回true，该方法就会返回true。</p>
<h4 id="3-2-8-缩小方法"><a href="#3-2-8-缩小方法" class="headerlink" title="3.2.8 缩小方法"></a>3.2.8 缩小方法</h4><p>a) reduce()<br>该方法从数组的第一项开始逐个遍历至尾，使用指定的函数来将数组的元素进行整合，只生成单个的值，这就是缩小方法，很好理解吧。另外，需要对该方法的参数进行说明一下，reduce()需要两个参数，第一个参数是执行化简操作的函数，这个参数必需；第二个参数是一个传递给函数的初试值，这里需要理解一下，所谓初始值就是传给第一个函数参数执行操作的第一个值，在接下来的操作中，这个值就是上一次函数的返回值了，而当第二个传参不使用时，化简函数就使用数组的第一个元素和第二个元素作为其第一个和第二个参数进行计算。请结合以下代码理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr=[1,2,3,4,4,5,6,6];</div><div class="line">var sum=arr.reduce(function (x, y)&#123; return x+y; &#125;, 0);	//数组元素求和</div><div class="line">var multi=arr.reduce(function (x, y)&#123; return x*y&#125;, 1);	//求出数组中各元素的积</div><div class="line">var max=arr.reduce(function (x, y)&#123; return (x&gt;y)?x:y&#125;);	//求出最大值为6</div></pre></td></tr></table></figure></p>
<p>b) reduceRight()<br>该方法的使用和reduce()是一样的，这里可以联想到indexOf()方法和lastIndexOf()方法的关系，即reduceRight()方法是按照数组索引从高到低的处理数组。</p>
<h2 id="4-数组和面向对象"><a href="#4-数组和面向对象" class="headerlink" title="4 数组和面向对象"></a>4 数组和面向对象</h2><h3 id="4-1数组和对象的关系"><a href="#4-1数组和对象的关系" class="headerlink" title="4.1数组和对象的关系"></a>4.1数组和对象的关系</h3><p>数组也是对象：使用typeof对一个数组运算后会返回的是字符串“object”，这便足以说明数组就是对象。</p>
<p>数组是有序存储数据的集合：数组是一段线性分配的内存，它可以通过整数去计算偏移并访问其中的元素，由此可以看出数组是有序对象存储的集合。</p>
<p>数组是一种访问速度很快的数据结构：因为数组的属性都是以数字形式存放在栈中，从栈中获取数据是非常快捷的。</p>
<p>类数组对象：而由于JavaScript中没有数组这样的数据结构，但却提供了一种拥有一些类数组特性的对象，将数组的下标转变成字符串，将其作为属性，这种我们称之为类数组对象。虽然类数组对象的访问速度比真正的数组慢，但它使用起来却更加的灵活方便，且其属性的检索和更新方式和对象都是一模一样的。</p>
<h3 id="4-2数组的前世今生"><a href="#4-2数组的前世今生" class="headerlink" title="4.2数组的前世今生"></a>4.2数组的前世今生</h3><p>Js中的Object是原始的类，负责构造对象，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Var obj=  &#123;name: ‘’,age:22, height:199 &#125;;</div></pre></td></tr></table></figure>
<p>但由于方法不足，提供了一套封装数据的基本模型，由于功能有限需要更改和改进，有了以下的关联数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Obj[‘name’];	//php中叫做关联数组，可以以字符串为索引，作为查找值的依据</div><div class="line">Obj[‘age’];</div></pre></td></tr></table></figure>
<p>Js是很小巧的语言，数组和对象都是轻量级的。把对象里面的一部分功能做了改进，把数字也可以作为属性，索引，这样改进的好处：数字可以进行简单的数学运算，这样就派生出了数组类—-Array类。<br>数组只能以数字为索引属性的对象，创建这个类的时候，在它的原型上定义了一些属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [‘1’, ‘2’, ‘3’];</div><div class="line">length属性；//Array.prototype.length</div><div class="line">splice方法；</div><div class="line">sort方法等,我们也可以定义出这些方法</div></pre></td></tr></table></figure>
<p>把这些方法定义在原型上，把0,1,2这些属性自定义在类上，这样就不用写属性，可以直接写值了。对象是非常简便苗条的描述数据类型，数组就是这样演变过来的，而且在对象的基础了加了一些功能而产生的，Array继承又丰富了Object类。</p>
<h3 id="4-3-对象和数组的同源性"><a href="#4-3-对象和数组的同源性" class="headerlink" title="4.3 对象和数组的同源性"></a>4.3 对象和数组的同源性</h3><p>我们可以在一对方括号中包围零个或多个用逗号分隔的值来方便的创建新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var empty=[];</div><div class="line">var num=[0,  1,  21.2, true, false, ‘string’, null, undefined, [‘another’, ‘array’], &#123;object: true&#125;, NaN, Infinity ];</div><div class="line">empty.length == 0;//true,数组empty的长度为0;</div><div class="line">num.length == 12; //true,数组num的长度为12，且数组中允许包好任意混合类型的值。</div></pre></td></tr></table></figure>
<p>在数组num中，数组的第一个值将自动获得属性名‘0’， 第二个值将获得属性名‘1’，依次类推，可以很直观的看到数组有序存储数据的特性。同样的，我们来看使用对象直接量来创建一个保存一样数据的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var num_obj=&#123;</div><div class="line">    ‘0’:0,</div><div class="line">    ‘1’:1,</div><div class="line">    ‘2’:21.2,</div><div class="line">    ‘3’:true,</div><div class="line">    ‘4’:false,</div><div class="line">    ‘5’:’string’,</div><div class="line">    ‘6’:null,</div><div class="line">    ‘7’:undefined,</div><div class="line">    ‘8’:[‘another’, ‘array’],</div><div class="line">    ‘9’:&#123;object:true&#125;,</div><div class="line">    ‘10’:NaN,</div><div class="line">    ‘11’:Infinity</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样我们就用对象直接量的方式保存了和数组num一样的数据，不同的是，我们需要指定每一项数据的相应属性名，才可以实现相同的目的。这是因为num继承自Array.prototype，而num_obj继承自Object.prototype，所以num可以有序存储数据而且还具有length（当然后面会接触到function也有length属性，而function也是对象，所以不能说只有数组有length而对象就没有length，这是不对的）。</p>
<h3 id="4-4检测数组类型"><a href="#4-4检测数组类型" class="headerlink" title="4.4检测数组类型"></a>4.4检测数组类型</h3><p>由于以上所讲述到的数组和对象的同源性，所以在JavaScript中对对象和数组的区别经常是混乱的，在对数组和对象的使用上也经常不明确，所以有必要明确两个误区：</p>
<ul>
<li>不要在必须使用数组时使用对象，或者在必须使用对象时使用了数组<br>选用数组或对象的规则：当属性名是小而连续的整数时，应该使用数组，或是当对属性的位置和排列顺序有特殊要求时，应该使用数组；否则，应该使用对象。</li>
<li>正确区分对象和数组<br>不能单纯的运用typeof来检测数组，这会出现‘object’，通过数组去重来正确理解：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//数组内单一数据类型去重复</div><div class="line">var a=[88,88,44,33,27,44,88,20,27,67,22,27,27];</div><div class="line">//var a=[2,2,2,2,2,2,2,2,2,2,2,2,2]</div><div class="line">Array.prototype.distinct=function ()&#123;//在Array原型上拓展去重方法</div><div class="line">	var a=this;</div><div class="line">	for(var j=0;j&lt;a.length-1;j++)&#123;//使用简单的双循环逐个比较</div><div class="line">		var item=a[j];//将待比较的数提出来</div><div class="line">		for(var i=j+1;i&lt;a.length;)&#123;</div><div class="line">			if(item===a[i])&#123;//待比较数与数组中其他数做比较</div><div class="line">				a.splice(i,1);	//两数相等，则删除相应项		</div><div class="line">			&#125;else&#123;</div><div class="line">				i++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">alert(a.distinct());</div><div class="line">alert(a);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这是简单的数组去重复，数组中没有包括对象类型数，都是简单的数值去重，在if逻辑表达式中会隐式的调用typeof运算符来判断数据类型。但是在数组中包含对象类型的值时，此时去重便不能实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var a=[88,88,&#123;&#125;,&#123;&#125;,&#123;&#125;,33,27,44,88,20,27,67,22,27,27];</div><div class="line">Array.prototype.distinct=function ()&#123;</div><div class="line">	var a=this;</div><div class="line">	var obj=&#123;&#125;;//把数组里的每个值，转变为这个对象属性和值。如果当前的这个值，没有出现重复</div><div class="line">	for(var i=0;i&lt;a.length;)&#123;</div><div class="line">		if(obj[a[i]]!=a[i])&#123;</div><div class="line">			//第一次是obj[88] !=88 obj[88]是undefined</div><div class="line">			//如果不等则是true，则给obj构建一个属性和值相同的键值对。说明它原来没有出现过，现在出现了则将其转化为对象的属性</div><div class="line">			//第二 obj[88]已经存在了</div><div class="line">			obj[a[i]]=a[i];//说明没有重复项</div><div class="line">			i++;</div><div class="line">		&#125;else&#123;</div><div class="line">			a.splice(i,1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">alert(a.distinct());</div><div class="line">alert(a);</div></pre></td></tr></table></figure></p>
<p>想知道去重后alert(a)的结果吗？</p>
<blockquote>
<p>小结：原来使用的typeof运算符对数组的检测是不严谨的，所以在数组中含有对象类型值时进行去重不能实现。但是，我们可以自定义一个方法来实现对数组和对象的判断。既然前面咱们已经学习了原型等知识，就可以自定义一个更加简洁的方法来检测数组类型了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var is_Array=function(value)&#123;</div><div class="line">	return Object.prototype.toString.apply(value) === &apos;[object Array]&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>补充：call和apply的应用和区别<br>A) call 和apply方法具有相同的功能，都可以直接改变被执行函数的作用域指向传参指定的新对象，即更改被执行函数的内部指针this的指向。这在面向对象的js编程过程中有时是很有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line">alert(this.x + this.y);</div><div class="line">&#125;</div><div class="line">var obj = &#123;x: 2, y: 1&#125;;</div><div class="line">fn.call(obj);	//弹出的结果为3</div></pre></td></tr></table></figure></p>
</blockquote>
<p>B) 两者的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Fn.call(context, arg1, arg2, arg3.....);//call方法中第二个以后的传参不限个数</div><div class="line">Fn.apply(context, arg[i]);		//apply方法第二个参数必须为数组，数组中为需要传递的参数</div></pre></td></tr></table></figure></p>
<h3 id="4-3数组方法模拟与扩展-深入理解prototype"><a href="#4-3数组方法模拟与扩展-深入理解prototype" class="headerlink" title="4.3数组方法模拟与扩展(深入理解prototype)"></a>4.3数组方法模拟与扩展(深入理解prototype)</h3><p>此讲主要是讲数组的原理性的东西<br>面向对象就是用来封装数据的，数组类就是典型的面向对象的类。一个是对数据的封装，归纳分类；另外一个是逻辑关系的分类，就是函数方法。以下分解几个方法，进一步探究Array上方法的由来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//复制数组里的第s到第e项之前，不影响原来的实例</div><div class="line">Array.prototype.slice = function(s, e)&#123;</div><div class="line">	var arr = [];</div><div class="line">	e = (typeof e == &apos;number&apos;)?e:this.length;</div><div class="line">	for(var i=s;i&lt;e;i++)&#123;</div><div class="line">		arr.push(this[i]);</div><div class="line">	&#125;</div><div class="line">	return arr;</div><div class="line">&#125;;</div><div class="line">var arr = [0,1,2,3,4,5,6,7,8];</div><div class="line">arr.slice();</div></pre></td></tr></table></figure>
<h4 id="4-3-1-数组去重复的实现"><a href="#4-3-1-数组去重复的实现" class="headerlink" title="4.3.1 数组去重复的实现"></a>4.3.1 数组去重复的实现</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">/*------------------------</div><div class="line"> *函数名称：Array.prototype.distinct</div><div class="line"> *功能描述：牺牲空间换时间，利用自定义属性的方法去重</div><div class="line"> *思    路：</div><div class="line"> *-----------------------*/</div><div class="line">Array.prototype.distinct=function ()&#123;</div><div class="line">	var obj=&#123;&#125;;//定义一个对象，用于存放数组中不重复的元素</div><div class="line">	for(var i=0;i&lt;this.length;)&#123;//遍历数组中的元素</div><div class="line">		if(obj[this[i]]!=this[i])&#123;//若obj对象中没有该属性值，则向obj中添加一个属性并设置对应属性值，属性和属性值均为该数组元素</div><div class="line">			obj[this[i]]=this[i];</div><div class="line">			i++;</div><div class="line">		&#125;else&#123;</div><div class="line">			this.splice(i,1);//如果obj中已经有了该数组元素，则把比较到的这个重复元素删除</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">/*------------------------</div><div class="line"> *函数名称：</div><div class="line"> *功能描述：forEach方法去重</div><div class="line"> *思   路：</div><div class="line"> *-----------------------*/</div><div class="line">Array.prototype.distinct=function ()&#123;</div><div class="line">	var a=[],obj=&#123;&#125;,temp=this;</div><div class="line">	temp.forEach(function (value, index, temp)&#123;</div><div class="line">		if(!obj[typeof (value)+value])	&#123;</div><div class="line">			a.push(value);</div><div class="line">			obj[typeof (value)+value]=true;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	return a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/*------------------------</div><div class="line"> *函数名称：</div><div class="line"> *功能描述：解决对象去重问题</div><div class="line"> *思   路：</div><div class="line"> *-----------------------*/</div><div class="line">function multiTypeDistinct (arr)&#123;</div><div class="line">	//判断对象类型的方法</div><div class="line">	function isEqual(obj1,obj2)&#123;</div><div class="line">		//判断两个对象的地址是否一样，地址一样则必相等，这里只为了优化性能</div><div class="line">		if(obj1===obj2)&#123;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		if(typeof(obj1)==&quot;object&quot;&amp;&amp;typeof(obj2)==&quot;object&quot;)&#123;</div><div class="line">			//判断两个对象类型一致且为object类型</div><div class="line">			var count=0;</div><div class="line">			for(var attr in obj1)&#123;</div><div class="line">				count++;</div><div class="line">				if(!isEqual(obj1[attr],obj2[attr]))&#123;</div><div class="line">					return false;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			for(var attr in obj2)&#123;</div><div class="line">				count--;</div><div class="line">			&#125;</div><div class="line">			return count==0;</div><div class="line">		&#125;else if(typeof(obj1)==&quot;function&quot;&amp;&amp;typeof(obj2)==&quot;function&quot;)&#123;</div><div class="line">			//判断两个对象类型一致且为function类型</div><div class="line">			if(obj1.toString()!==obj2.toString())&#123;</div><div class="line">				return false;</div><div class="line">			&#125;</div><div class="line">		&#125;else &#123;	//判断两个对象类型不一致，再判断值是否相等</div><div class="line">			if(obj1!=obj2)&#123;</div><div class="line">				return false;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;;</div><div class="line">	//temp作为传入数组arr的备份，在不改变原数组的基础上进行去重操作</div><div class="line">	var temp=arr.slice(0);</div><div class="line">	for(var i=0;i&lt;temp.length;i++)&#123;</div><div class="line">		for(j=i+1;j&lt;temp.length;j++)&#123;</div><div class="line">			if(isEqual(temp[j],temp[i]))&#123;</div><div class="line">				temp.splice(j,1);//删除该元素</div><div class="line">				j--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return temp;</div><div class="line">&#125;</div><div class="line">/*------------------------</div><div class="line"> *函数名称：listToArray()</div><div class="line"> *功能描述：将nodeList类型转化为数组</div><div class="line"> *思   路：</div><div class="line"> *-----------------------*/</div><div class="line">function listToArray(eles)&#123;</div><div class="line">	try&#123;</div><div class="line">		return Array.prototype.slice.call(eles,0)</div><div class="line">	&#125;catch(e)&#123;//如果try里的代码出现了异常，则执行catch里的代码</div><div class="line">		var a=[];</div><div class="line">		for(var i=0;i&lt;eles.length;i++)&#123;</div><div class="line">			a.push(eles[i]);</div><div class="line">		&#125;</div><div class="line">		return a;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*------------------------</div><div class="line"> *函数名称：stringDist</div><div class="line"> *功能描述：字符串转换成数组去重</div><div class="line"> *思   路：</div><div class="line"> *-----------------------*/</div><div class="line">var str=&apos;777748908883859999&apos;;</div><div class="line">var arr=[].slice.call(str,0);//将字符串转化为数组</div><div class="line">function stringDist(arr)&#123;</div><div class="line">	var obj=&#123;&#125;,a=[];</div><div class="line">	for(var i=0,len=arr.length;i&lt;len;i++)&#123;</div><div class="line">		var temp=arr[i];		</div><div class="line">		if(!obj.hasOwnProperty(temp))&#123;	//判断obj对象是否具有temp属性</div><div class="line">			obj[temp]=1;</div><div class="line">			a.push(temp);</div><div class="line">		&#125;else&#123;</div><div class="line">			obj[temp]++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">	//return obj;	//返回每一项及其重复的个数</div><div class="line">&#125;</div><div class="line">console.log(stringDist(arr));</div></pre></td></tr></table></figure>
<h4 id="4-3-2-数组克隆的实现"><a href="#4-3-2-数组克隆的实现" class="headerlink" title="4.3.2 数组克隆的实现"></a>4.3.2 数组克隆的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Array.prototype.clone = function()&#123;</div><div class="line">	return this.slice(0);	//利用js内置的方法，执行效率特别高</div><div class="line">&#125;;</div><div class="line">Array.prototype.clone = function()&#123;</div><div class="line">	var a = [];</div><div class="line">	for(var i=0;i&lt;this,length;i++)&#123;</div><div class="line">		a.push(this[i]);</div><div class="line">	&#125;</div><div class="line">	return a;</div><div class="line">&#125;;</div><div class="line">//测试</div><div class="line">var a = [3,44,5,6,66];</div><div class="line">var a1 = a.clone();</div><div class="line">alert(a1 == a);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git和Github学习--基础篇]]></title>
      <url>http://pengfei6.github.io/2014/10/10/Git%E5%92%8CGithub%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>作为新时代的好码农，使用git和github来进行学习和交流是必备技能之一。什么，你都没听过，我擦勒，还能不能愉快的玩耍了。掌握git和github的使用，可以带你装逼带你飞，比如说，可以抄大婶的代码啊，哈哈…(此处省略一万个暗笑)。还可以直接看流行技术的源码和demo啊，再也不用去各大群里弱弱的问：大神，react怎么学啊，大牛，教我nodejs吧…。还有还有，要是你愿意，可以给开源项目贡献代码啊，当然，也可以把自己的牛逼项目开源出来，在这里和大家分享。另外，大婶什么的，都在这里活动，咱也来混个脸熟，从此走向高大上啊有木有。好了，吹牛完毕，学好git用在工作中好好搬砖才是正经事，在github上学到好技术升职加薪迎娶白富美才是正经事，你梭484啊。<br><a id="more"></a></p>
<h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.创建版本库"></a>1.创建版本库</h2><ul>
<li>安装git，至于这个话题就不细说了，按照你电脑的操作系统下载一个合适的git，需要注意的是，配置好环境变量，以便全局可以使用git命令。</li>
<li>那么，接下来就开始打开你的git bash吧，如果愿意，不妨设置一下你的git bash的界面外观，至少自己看着舒服，写码都感觉是件很愉悦的事情，对吧。</li>
<li>新建git仓库之前，需要你配置一些个人信息，如果你慢慢的入门了，还可以配置些alias别名，让你使用git健步如飞。<br>git config –global user.email “you@example.com” 配置邮件<br>git config –global user.name “Your Name” 配置用户名<br>这两项是必须配置，否则后面的commit、push到远程库都会失败。至于别名，后面再聊</li>
<li>现在开始愉快的玩耍了，先cd 到你的一个目录（以windows操作系统为例），比如：cd d:</li>
<li>先创建目录，作为仓库：mkdir myrepo</li>
<li>git init 初始化仓库，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了</li>
<li>vim readme.txt 新建一个文本文件，比如往里面添加简单的一行字符串</li>
<li>git add readme.txt 添加一个文件，比如readme.txt，如果目录里面的所有文件都要添加，可以git add *</li>
<li>git commit-m “添加一个readme.txt文件” 将文件提交到仓库，并加上说明（这时候是版本1）</li>
</ul>
<h2 id="2-提交修改"><a href="#2-提交修改" class="headerlink" title="2.提交修改"></a>2.提交修改</h2><p>假如此时第一次修改了readme.txt文件</p>
<ul>
<li>git status 让我们时刻掌握仓库当前的状态。这时告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</li>
<li>git diff readme.txt 查看对readme.txt做了什么修改</li>
<li>git add readme.txt 提交修改和提交新文件是一样，先git add</li>
<li>git status 可以再用git status查看仓库的当前状态，告诉我们，将要被提交的修改包括readme.txt</li>
<li>git commit-m “第一次修改” 然后再git commit，并添加修改的描述（这时候是版本2）</li>
<li>git status 可以再执行git status看仓库状态，因为所有的都提交了，Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。</li>
</ul>
<h2 id="3-版本回退"><a href="#3-版本回退" class="headerlink" title="3.版本回退"></a>3.版本回退</h2><p>你可以像上面所说的那样不停的提交新的文件、提交对文件的修改<br>这时候第二次修改readme.txt文件</p>
<ul>
<li>git add readme.txt 先git add</li>
<li>git commit -m “第二次修改” 提交第二次修改（这时候是版本3）</li>
<li>git log 显示从最近到最远的提交日志，具体显示的内容自己试一试看看</li>
<li>git log –pretty=oneline 如果嫌输出信息太多，看得眼花缭乱，试试加上–pretty=oneline参数<br>看这篇教程去理解为什么Git的版本号要这么长，Git的版本号类似：3628164fb26d48395383f8f31179f24e0882e1e0 这样的特别长的十六进制数。</li>
<li>git reset –hard HEAD^ 会回退到上一个版本，也就是从版本3回退到版本2<br>在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</li>
<li>vim readme.txt 可以看到此时的readme.txt文件就是版本2时候的内容，回退成功！<br>git log 此时看到版本3的信息没有了</li>
<li>git reset –hard 3628164 通过命令行上的历史信息（假如你没清屏的话），找到版本3 的版本号，不一定要全部的版本号，就像这个命令的例子，只要前面的约7、8位这样就可以指定回到版本3</li>
<li>vim readme.txt 看到的是第三版本的readme.txt文件的内容，所以又回来了<br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向你要回退的那个版本</li>
<li>git reflog 记录你的每一次命令，最先显示的是这个命令执行之后的版本的版本号的前七位，这样就算你清屏了或者重启了，也能找到某个版本的版本号，就可以轻松回退到那个版本</li>
</ul>
<h2 id="4-工作区、版本库和暂存区"><a href="#4-工作区、版本库和暂存区" class="headerlink" title="4.工作区、版本库和暂存区"></a>4.工作区、版本库和暂存区</h2><p>工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。</p>
<p>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>详细知识见这篇教程。必须理解暂存区、工作区、版本库。这些都是是Git非常重要的概念，弄明白了这些概念，就弄明白了Git的很多操作到底干了什么。没弄明白的话，请反复看！！</p>
<h2 id="5-管理修改"><a href="#5-管理修改" class="headerlink" title="5.管理修改"></a>5.管理修改</h2><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>通过实例讲解什么叫跟踪修改，要想理解，请参考原文结合暂存区的知识理解：</p>
<ul>
<li>vim readme.txt 编辑文件，比如添加新的一行</li>
<li>git add readme.txt 添加，但是不提交</li>
<li>vim readme.txt 再编辑文件，比如再添加一行</li>
<li>git commit -m “修改两次，添一次，提交一次” 提交</li>
<li>git status 看到的效果是：只提交了第一次的修改，第二次的修改没有提交<br>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，也就是第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit，就相当于把两次修改合并后一块提交了。</li>
</ul>
<h2 id="6-撤销修改"><a href="#6-撤销修改" class="headerlink" title="6.撤销修改"></a>6.撤销修改</h2><p>第一种情况</p>
<p>修改了readme.txt文件，还没有git add 和git commit<br>但是在你提交之前发现这次修改有问题。既然错误发现得很及时，就可以很容易地纠正它。你可以手动把文件恢复到上一个版本的状态。<br>git checkout – readme.txt 也可以通过命令撤销修改，这条命令的意思就是，把readme.txt文件在工作区的修改全部撤销<br>无论是文件修改后值存在于工作区还没有放到暂存区，还是已经添加到暂存区，总之这个命令就是让这个文件回到最近一次git commit或git add时的状态。<br>查看文件，内容果然复原了。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。<br>第二种情况</p>
<p>修改了readme.txt文件，而且执行了git add readme.txt<br>庆幸的是你在 git commit 之前发现了这个问题</p>
<ul>
<li>git status 查看一下，修改只是添加到了暂存区，还没有提交</li>
<li>git reset HEAD readme.txt 可以把暂存区的修改撤销掉，重新放回工作区。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</li>
<li>git status 查看一下，现在暂存区是干净的，工作区有修改</li>
<li>git checkout – readme.txt 还记得第一种情况中如何丢弃工作区的修改吧<br>第三种情况</li>
</ul>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p>
<p>还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把错误的修改（如果是影响很大的错误）提交推送到远程版本库，你就真的惨了……</p>
<p>区别对待本地版本库和远程版本库！</p>
<h2 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7.删除文件"></a>7.删除文件</h2><p>在Git中，删除也是一个修改操作</p>
<p>添加一个新的文件 test.txt</p>
<ul>
<li>git add test.txt</li>
<li>git commit test.txt -m “再次新增一个文件”<br>一般情况下，你通常会在文件管理器中把没用的文件删除，或者直接rm test.txt</li>
<li>git status 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了<br>现在你有两个选择，一是确实从版本库中删除该文件，那就git rm test.txt，然后git commit 文件就从版本库中删除了<br>另一种情况是删除错了，因为版本库里还有，所以可以轻松地将误删除的文件恢复到最新版本git checkout – test.txt git checkout其实使用版本库中的版本替换工作区的版本，无论工作区是修改还是删除，都可以’一键还原’</li>
</ul>
<h2 id="8-添加远程库"><a href="#8-添加远程库" class="headerlink" title="8.添加远程库"></a>8.添加远程库</h2><p>要想学习这部分的知识，需要先在github上添加你的ssh keys。</p>
<ul>
<li>回到你的github首页，点击你自己的小头像，出现下拉选项，选择settings。</li>
<li>这个时候打开了新页面，请看页面左侧，找到ssh keys选项，点击进入</li>
<li>点击add ssh keys按钮，就可以添加你本地的ssh keys了</li>
</ul>
<p>好了，问题来了，我本地的ssh keys在哪里呢，或是怎么获取呢。很简单，咱们一步步来看。</p>
<ul>
<li>回到你的git bash窗口</li>
<li>键入以下命令：ssh-keygen -t rsa -C “你的邮箱地址”</li>
<li>最后得到了两个文件：id_rsa和id_rsa.pub，需要把刚才生成的id_rsa.pub里面的内容复制粘贴到刚才的github页面上的ssh keys里面即可</li>
<li>cat ~/.ssh/id_rsa.pub就可以查看到内容</li>
</ul>
<p>那么，咱们还有一个简单的过程，就是在你的github上添加一个仓库啊</p>
<ul>
<li>这个就不细说了，在你的github首页上面，你的头像旁边有个加号，点击就会出现下拉选项</li>
<li>选择new repository，接下来的过程就新建一个你的git仓库吧。</li>
</ul>
<p>假如现在你已经配置好github，并且在github上添加了learngit仓库。</p>
<ul>
<li>git remote add origin git@github.com:iUAP-FE/learngit.git 这个命令是在本地的learngit仓库下执行的，前面通过learngit仓库为例我们已经讲过在本地创建和操作git仓库。这两个地方的仓库名不需要相同，因为会通过在本地的仓库目录下执行这条命令（命令中包含远程库的名字）已经将两者建立了联系<br>请千万注意，把上面的iUAP-FE替换成你自己的GitHub账户名，learngit替换为你的github上的仓库名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</li>
<li>git push -u origin master 把本地库的所有内容推送到远程库上。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>然后去Github对应的远程库看看，都已经推送上去了。<br>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。<br>这样你就可以在Github上托管你的项目代码、重要的文档……</li>
</ul>
<h2 id="9-从远程库克隆"><a href="#9-从远程库克隆" class="headerlink" title="9.从远程库克隆"></a>9.从远程库克隆</h2><p>假设我的github上面有一个远程库，但是本地没有，需要克隆到本地，远程库的名字叫’gitskills’</p>
<ul>
<li>git clone git@github.com:iUAP-FE/learngit.git 克隆一个本地库</li>
<li>cd gitskills 进入克隆下来的本地库，默认的名字是和github上的一样的</li>
<li>ls -al 可以看到本地的克隆库里面是和远程库里面的一样的<br>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。<br>你也许还注意到，GitHub给出的地址不止一个，还可以用git@github.com:iUAP-FE/learngit.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</li>
</ul>
<p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p>
<h2 id="10-分支管理"><a href="#10-分支管理" class="headerlink" title="10.分支管理"></a>10.分支管理</h2><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h2 id="11-创建和合并分支"><a href="#11-创建和合并分支" class="headerlink" title="11.创建和合并分支"></a>11.创建和合并分支</h2><p>首先教程中会详细讲解分支的原理（分支、指针、工作区……），一定要好好看！！看完之后你才能对你的创建分支和合并分支的操作不只是会用，更能在用的时候没有任何疑惑！反正能学到更多的知识，何乐而不为！</p>
<p>另外推荐这样的博客：使用git和github进行协同开发流程以及我的学习笔记使用git和github管理自己的项目—真实开发环境的策略。</p>
<p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，我们练习的learngit，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>开始实战：</p>
<ul>
<li>git checkout -b dev 创建一个新的分支：dev，并且会切换到dev分支。所以这条命令有两个作用。git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev 和 git checkout dev<br>补充：所有的git管理的项目刚开始时候默认有一条分支：master</li>
<li>git branch 查看当前所在的分支。git branch命令会列出所有分支，当前分支前面会标一个*号。<br>因为切换到dev分支，所以我们现在可以在dev分支上正常提交，比如对readme.txt做一个修改</li>
<li>git add readme.txt</li>
<li>git commit -m “提交到dev分支”</li>
<li>git checkout master 现在，dev分支的工作完成，我们就可以切换回master分支<br><em>注意:</em>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变</li>
<li>git merge dev 这是在master分支上执行的命令，作用是：把dev分支上的工作成果合并到master分支上</li>
<li>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。</li>
<li>git branch -d dev 合并完成之后，可以放心的删除dev分支了</li>
<li>git branch 删除后，查看branch，只剩下master了</li>
</ul>
<h2 id="12-解决冲突"><a href="#12-解决冲突" class="headerlink" title="12.解决冲突"></a>12.解决冲突</h2><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<ul>
<li>git checkout -b feature1 创建新的分支feature1，并且换到这个分支，进行新的实验<br>在feature1分支下，假如将readme.txt的最后一行由”test branch” 改为”test feature1”</li>
<li>git add readme.txt</li>
<li>git commit -m “在feature1上修改readme.txt的最后一行” 在feature1分支上提交</li>
<li>git checkout master 切换到master分支。Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。<br>在master分支下，假如将readme.txt的最后一行由”test branch” 改为”test master”因为上面的是在feature1上进行的修改，所以切换回master之后，看到的文件并不是在feature1上修改后的文件</li>
<li>git add readme.txt</li>
<li>git commit -m “又在master上修改了readme.txt文件” 在master上也提交修改<br>现在，master分支和feature1分支各自都分别有新的提交</li>
<li>git merge feature1 在master分支上执行该命令，与feature1分支合并。这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交</li>
<li>git status git status也可以告诉我们冲突的文件<br>这时候使用vim等编辑器打开readme.txt文件可以看到已经在readme.txt文件中将冲突的信息已经添加到里面了，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容<br>然后我们编辑readme.txt文件，处理冲突，将内容改成我们想要的样子</li>
<li>git add readme.txt</li>
<li>git commit -m “解决冲突” 在master上提交</li>
<li>git log –graph –pretty=oneline –abbrev-commit 用带参数的git log可以看到分支的合并情况。用git log –graph命令可以看到分支合并图。</li>
<li>git branch -d feature1 最后删除feature分支，完成工作。</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
