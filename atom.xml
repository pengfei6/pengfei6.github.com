<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>semifi&#39;s Notes</title>
  <subtitle>一只爱健身的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-12T14:30:13.915Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>semifi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章标题</title>
    <link href="http://yoursite.com/2016/09/12/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"/>
    <id>http://yoursite.com/2016/09/12/文章标题/</id>
    <published>2016-09-12T14:30:13.000Z</published>
    <updated>2016-09-12T14:30:13.915Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Generator 函数的含义与用法</title>
    <link href="http://yoursite.com/2015/06/08/Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2015/06/08/Generator 函数的含义与用法/</id>
    <published>2015-06-08T14:22:38.000Z</published>
    <updated>2016-09-08T14:47:19.995Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="external">阮一峰博客</a></p>
<ul>
<li>以前异步编程的方法，大概有下面四种：<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
</li>
<li>异步编程的语法目标，就是怎样让它更像同步编程。</li>
</ul>
<h3 id="一、什么是异步？（省略。。。）"><a href="#一、什么是异步？（省略。。。）" class="headerlink" title="一、什么是异步？（省略。。。）"></a>一、什么是异步？（省略。。。）</h3><h3 id="二、回调函数的概念"><a href="#二、回调函数的概念" class="headerlink" title="二、回调函数的概念"></a>二、回调函数的概念</h3><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，<br>等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用”。读取文件进行处理，是这样写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。<br>一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？<br>原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="三、Promise-为解决回调函数噩梦"><a href="#三、Promise-为解决回调函数噩梦" class="headerlink" title="三、Promise (为解决回调函数噩梦)"></a>三、Promise (为解决回调函数噩梦)</h3><p>Promise不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</div><div class="line"></div><div class="line">readFile(fileA)</div><div class="line">.then(function(data)&#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(function()&#123;</div><div class="line">  return readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(function(data)&#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(function(err) &#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，我使用了 fs-readfile-promise 模块，它的作用就是返回一个 Promise 版本的 readFile 函数。<br>Promise 提供 then 方法加载回调函数，catch方法捕捉执行过程中抛出的错误。<br>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。<br>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<h3 id="四、协程"><a href="#四、协程" class="headerlink" title="四、协程"></a>四、协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">第一步，协程A开始执行。</div><div class="line">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</div><div class="line">第三步，（一段时间后）协程B交还执行权。</div><div class="line">第四步，协程A恢复执行。</div></pre></td></tr></table></figure></p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。<br>举例来说，读取文件的协程写法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function asnycJob() &#123;</div><div class="line">  // ...其他代码</div><div class="line">  var f = yield readFile(fileA);</div><div class="line">  // ...其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。<br>它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="五、Generator函数的概念"><a href="#五、Generator函数的概念" class="headerlink" title="五、Generator函数的概念"></a>五、Generator函数的概念</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。<br>异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next() // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。<br>调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。<br>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。<br>value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="六、Generator-函数的数据交换和错误处理"><a href="#六、Generator-函数的数据交换和错误处理" class="headerlink" title="六、Generator 函数的数据交换和错误处理"></a>六、Generator 函数的数据交换和错误处理</h3><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。<br>除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。<br>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next(2) // &#123; value: 2, done: true &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。<br>第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。<br>因此，这一步的 value 属性，返回的就是2（变量 y 的值）。<br>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function* gen(x)&#123;</div><div class="line">  try &#123;</div><div class="line">    var y = yield x + 2;</div><div class="line">  &#125; catch (e)&#123; </div><div class="line">    console.log(e);</div><div class="line">  &#125;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line">var g = gen(1);</div><div class="line">g.next();</div><div class="line">g.throw（&apos;出错了&apos;）;</div><div class="line">// 出错了</div></pre></td></tr></table></figure></p>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try … catch 代码块捕获。<br>这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="Generator-函数的用法"><a href="#Generator-函数的用法" class="headerlink" title="Generator 函数的用法"></a>Generator 函数的用法</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fetch = require(&apos;node-fetch&apos;);</div><div class="line">function* gen()&#123;</div><div class="line">  var url = &apos;https://api.github.com/users/github&apos;;</div><div class="line">  var result = yield fetch(url);</div><div class="line">  console.log(result.bio);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。<br>执行这段代码的方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var g = gen();</div><div class="line">var result = g.next();</div><div class="line">result.value.then(function(data)&#123;</div><div class="line">  return data.json();</div><div class="line">&#125;).then(function(data)&#123;</div><div class="line">  g.next(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个next 方法。<br>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。本系列的后面部分，就将介绍如何自动化异步任务的流程管理。<br>另外，本文对 Generator 函数的介绍很简单，详尽的教程请阅读我写的<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="external">《ECMAScript 6入门》</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/04/generator.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰博客&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以前异步编程的方法，大概有下面四
    
    </summary>
    
    
      <category term="Generator" scheme="http://yoursite.com/tags/Generator/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="回调" scheme="http://yoursite.com/tags/%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
</feed>
