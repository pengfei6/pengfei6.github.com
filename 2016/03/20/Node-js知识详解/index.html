<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="google9707cecf254225e9.html"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="node,JavaScript,Node,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="Chapter 1 – Node.js入门知识
导读：在这一部分的内容里，主要会简单介绍一下什么是Node.js，它有哪些用武之地，我们为什么要去学习它。另外，还会简单的讨论下Nodejs的优缺点以及适用场景。

基本介绍Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.j"><meta property="og:type" content="article"><meta property="og:title" content="Node.js知识详解"><meta property="og:url" content="http://pengfei6.github.io/2016/03/20/Node-js知识详解/index.html"><meta property="og:site_name" content="semifi's Notes"><meta property="og:description" content="Chapter 1 – Node.js入门知识
导读：在这一部分的内容里，主要会简单介绍一下什么是Node.js，它有哪些用武之地，我们为什么要去学习它。另外，还会简单的讨论下Nodejs的优缺点以及适用场景。

基本介绍Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.j"><meta property="og:image" content="http://pengfei6.github.io/img/model1.jpg"><meta property="og:image" content="http://pengfei6.github.io/img/model2.jpg"><meta property="og:image" content="http://pengfei6.github.io/img/model3.jpg"><meta property="og:image" content="http://pengfei6.github.io/img/require.jpg"><meta property="og:updated_time" content="2016-09-20T14:44:28.241Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Node.js知识详解"><meta name="twitter:description" content="Chapter 1 – Node.js入门知识
导读：在这一部分的内容里，主要会简单介绍一下什么是Node.js，它有哪些用武之地，我们为什么要去学习它。另外，还会简单的讨论下Nodejs的优缺点以及适用场景。

基本介绍Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.j"><meta name="twitter:image" content="http://pengfei6.github.io/img/model1.jpg"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0x57d2df6cebc04400,author:"作者"}}</script><link rel="canonical" href="http://pengfei6.github.io/2016/03/20/Node-js知识详解/"><title> Node.js知识详解 | semifi's Notes</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">semifi's Notes</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">一只爱健身的程序猿</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> Node.js知识详解</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-03-20T22:40:05+08:00" content="2016-03-20">2016-03-20</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/NODE/" itemprop="url" rel="index"><span itemprop="name">NODE</span></a></span></span> <span class="post-comments-count">&nbsp; | &nbsp;<a href="/2016/03/20/Node-js知识详解/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/03/20/Node-js知识详解/" itemprop="commentsCount"></span></a></span> <span id="/2016/03/20/Node-js知识详解/" class="leancloud_visitors" data-flag-title="Node.js知识详解">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Chapter-1-–-Node-js入门知识"><a href="#Chapter-1-–-Node-js入门知识" class="headerlink" title="Chapter 1 – Node.js入门知识"></a>Chapter 1 – Node.js入门知识</h1><blockquote><p>导读：在这一部分的内容里，主要会简单介绍一下什么是Node.js，它有哪些用武之地，我们为什么要去学习它。另外，还会简单的讨论下Nodejs的优缺点以及适用场景。</p></blockquote><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</strong></p><p>以上提到的<strong>运行环境</strong>，我们可以这样理解：</p><blockquote><p>JS本身是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。<br>而对于需要独立运行的JS，NodeJS就是一个解析器，是JS语言的服务器运行环境，使其流畅的运行于服务器端。<br><a id="more"></a><br><strong>Nodejs的特点是：</strong></p></blockquote><ol><li><p>JavaScript运行环境，相当于js在服务端的一个宿主环境</p></li><li><p>依赖于Chrome V8引擎进行代码解释，V8引擎执行Javascript的速度非常快，性能非常好。</p></li><li><p>事件驱动</p></li><li><p>非阻塞I/O</p></li><li><p>轻量、可伸缩，适于实时数据交互应用</p></li><li><p>单进程，单线程</p></li><li><p>Node提供核心功能模块，使得JavaScript语言可以实现文件的读写、进程管理以及网络通信等功能，在这个意义上，Node又是JavaScript的工具库。</p></li></ol><h2 id="为什么要学nodejs"><a href="#为什么要学nodejs" class="headerlink" title="为什么要学nodejs"></a>为什么要学nodejs</h2><p>包括但不限于以下几点。</p><h3 id="Nodejs市场活跃"><a href="#Nodejs市场活跃" class="headerlink" title="Nodejs市场活跃"></a>Nodejs市场活跃</h3><ul><li>从<a href="https://www.npmjs.com/" target="_blank" rel="external">npmjs.org</a>社区可以看到，有超过20W的第三方package，每天亿级以上的下载量。</li><li><a href="https://github.com/" target="_blank" rel="external">github.com</a>上搜索node相关的项目，15万个以上。</li><li>而且社区非常活跃，参与的开发者众多</li></ul><h3 id="Nodejs应用广泛"><a href="#Nodejs应用广泛" class="headerlink" title="Nodejs应用广泛"></a><strong>Nodejs应用广泛</strong></h3><p>我们来看使用nodejs可以做什么：</p><ul><li>项目管理：npm,grunt, gulp,bower, yeoman</li><li>桌面应用: node-webkit</li><li>Web开发：express,ejs,hexo, socket.io, restify, cleaver, stylus, browserify,cheerio</li><li>工具包 underscore,moment,connet,later,log4js,passport,passport(oAuth),domain,require,reap,commander,retry,PDFkit</li><li>数据库：mysql,mongoose,redis,memcached</li><li>异步：async,wind,eventProxy,bluebird</li><li>部署：forever,pm2,nodemon</li><li>测试：jasmine,karma,protractor</li><li>跨平台：rio,tty</li><li>内核：cluster,http,request</li><li>模板: jade</li><li>博客: ghost,hexo</li><li>微信: weui</li><li>硬件控制: NoduinoWeb</li><li>操作系统: NodeOS</li></ul><blockquote><p>可以这么说，其他语言能做的事情，nodejs都可以做，甚至可以做的更好（不知道这样说会被会被人喷）。当然，更需要结合业务具体分析进行技术选型。</p></blockquote><h3 id="推荐关注"><a href="#推荐关注" class="headerlink" title="推荐关注"></a><strong>推荐关注</strong></h3><ol><li><p><a href="https://github.com/" target="_blank" rel="external">github</a>：在这里可以找到大量nodejs相关的项目，阅读源码源码，查看新技术的一手资料</p></li><li><p><a href="https://nodejs.org" target="_blank" rel="external">nodejs官网</a>：关注Node版本更新，包括api功能及使用、bug修复、新增特性以及未来的发展趋势</p></li><li><p><a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>：在这里搜索你想用的包，参考别人的源代码</p></li><li><p><a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow问答社区</a>：有什么疑惑直接在这开问吧，会有很多热情的好基友来帮你解答问题的，比如服务异常、配置什么的。</p></li></ol><h2 id="NodeJS优缺点及适用场景讨论"><a href="#NodeJS优缺点及适用场景讨论" class="headerlink" title="NodeJS优缺点及适用场景讨论"></a>NodeJS优缺点及适用场景讨论</h2><p>基于以上提及的Nodejs特性，我们来看在实际系统问题中是如何体现其优势的。</p><p>Nodejs的出现为我们解决现实当中系统瓶颈提供了新的思路和方案</p><h4 id="解决并发连接的问题"><a href="#解决并发连接的问题" class="headerlink" title="解决并发连接的问题"></a>解决并发连接的问题</h4><p>对于并发连接的问题讨论，为了有更直观的理解，我们来看以下三个模型：</p><ul><li>系统线程模型</li></ul><p><img src="/img/model1.jpg" alt=""></p><p>这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达只能处理一个，其余的要先等待，这就是阻塞，正在享受服务的请求阻塞后面的请求了。</p><ul><li>多线程、线程池模型</li></ul><p><img src="/img/model2.jpg" alt=""></p><p>这个模型已经比上一个有所进步，它调节服务端线程的数量来提高对并发请求的接收和响应，但并发量高的时候，请求仍然需要等待。它有个更严重的问题，即服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以PHP为例，维护一个连接可能需要20M的内存。这就是为什么一般并发量一大，就需要多开服务器的原因。</p><ul><li>异步、事件驱动模型</li></ul><p>那么我们来看nodejs是如何处理这个问题的</p><p><img src="/img/model3.jpg" alt=""></p><p>我们同样是要发起请求，等待服务器端响应；但不同的是，点完餐拿到号码后，我们往往会在位置上等待，而在我们后面的请求会继续得到处理，同样是拿了一个号码然后到一旁等待，接待员能一直进行处理。</p><p>等到饭菜做好了，会喊号码，我们拿到了自己的饭菜，进行后续的处理（吃饭）。这个喊号码的动作在NodeJS中叫做回调（Callback），能在事件（烧菜，I/O）处理完成后继续执行后面的逻辑（吃饭），这体现了NodeJS的显著特点：异步机制、事件驱动整个过程没有阻塞新用户的连接（点餐），也不需要维护已经点餐的用户与厨师的连接。</p><p>基于这样的机制，理论上陆续有用户请求连接，NodeJS都可以进行响应，因此NodeJS能支持比Java、PHP程序更高的并发量。</p><p>虽然维护事件队列也需要成本，但由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上去后面对CPU密集型模型的时候就还是会力不从心，因此依然被部分人诟病。但好在，活跃的社区在持续的解决各种问题，应运而生的<a href="https://github.com/xk/node-threads-a-gogo" target="_blank" rel="external">threads-a-gogo（以下简称TAGG）</a>这个模块就是让node支持多线程模型。</p><blockquote><p>总结一下NodeJS是怎么解决并发连接这个问题的：更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。</p></blockquote><h4 id="解决I-O阻塞的问题"><a href="#解决I-O阻塞的问题" class="headerlink" title="解决I/O阻塞的问题"></a>解决I/O阻塞的问题</h4><p>NodeJS解决的另外一个问题是I/O阻塞，看看这样的业务场景：需要从多个数据源拉取数据，然后进行处理，处理的方式有：</p><ol><li>串行获取数据，这是我们一般的解决方案</li><li>NodeJS非阻塞I/O，是通过发射/监听事件来控制执行过程</li></ol><p>NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行，事件代理接收到线程后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。</p><p>我们来看以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * [require description]</div><div class="line"> * @param  &#123;[type]&#125; &apos;events&apos; [description]</div><div class="line"> * @return &#123;[type]&#125;          [description]</div><div class="line"> */</div><div class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</div><div class="line">var event = new EventEmitter();</div><div class="line"></div><div class="line">event.on(&apos;eat&apos;, function() &#123;</div><div class="line">	console.log(&apos;开饭啦&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;我要先去散步&apos;);</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">	event.emit(&apos;eat&apos;);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><h4 id="综合对比分析"><a href="#综合对比分析" class="headerlink" title="综合对比分析"></a>综合对比分析</h4><ol><li>Nodejs具有处理高并发的能力（最重要的优点）</li><li>Nodejs适合I/O密集型应用</li><li>Nodejs不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；</li></ol><p>解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；或者使用第三方模块，让Node也可以创建多进程。</p><p>当然，也有很多人吐槽：</p><ol><li><p>只支持单核CPU，不能充分利用CPU</p></li><li><p>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃，原因是nodejs是单进程单线程</p></li></ol><p>But，现在我们都有解决方案：<br>（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；<br>（2）开多个进程监听同一个端口，使用cluster模块；</p><p>戳这里了解<a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/" target="_blank" rel="external">更多</a></p><blockquote><p>总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。</p></blockquote><h1 id="Chapter-2-–-Node-js基础知识"><a href="#Chapter-2-–-Node-js基础知识" class="headerlink" title="Chapter 2 – Node.js基础知识"></a>Chapter 2 – Node.js基础知识</h1><blockquote><p>导读：在这一部分的基础内容中，将会学习如何安装并体验Nodejs，了解Nodejs里面的模块以及相关的代码规范。同时，还可以学习npm包管理器的使用。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows上安装"><a href="#windows上安装" class="headerlink" title="windows上安装"></a>windows上安装</h3><ul><li>先去下载一下<a href="http://git-scm.com/download/" target="_blank" rel="external">git</a>的客户端，可以运行git bash，方便使用shell命令</li></ul><p><code>step1.</code> 进入<a href="https://nodejs.org/" target="_blank" rel="external">nodejs.org</a>下载</p><p><code>step2.</code> 下载完成后，双击默认安装。安装程序会自动添加环境变量</p><p><code>step3.</code> 检测nodejs是否安装成功。打开cmd命令行 输入 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node - v</div></pre></td></tr></table></figure><p><code>step4.</code> 检查npm是否安装。由于新版的NodeJS已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行进行确认。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm -v</div></pre></td></tr></table></figure><h3 id="mac上安装"><a href="#mac上安装" class="headerlink" title="mac上安装"></a>mac上安装</h3><ul><li>升级系统</li><li><p>升级xcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcode-select -p</div><div class="line">xcode-select --install</div></pre></td></tr></table></figure></li><li><p>安装Homebrew<br>前提是python和ruby安装好<br>官网查看方法</p></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure></li><li><p>检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure></li></ul><h3 id="linux上安装"><a href="#linux上安装" class="headerlink" title="linux上安装"></a>linux上安装</h3><ul><li>先要扫平环境问题<br>也可以到官网查看<br>要求gcc 4.2+和g++ 4.2+以及python 2.6和gnu的版本要求</li><li>检查<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat /etc/redhat-release</div><div class="line">rpm -q gcc rpm -q gcc-c++</div><div class="line">yum -y install gcc gcc-c++ kernel-devel</div></pre></td></tr></table></figure></li></ul><p>ubuntu下可以apt-get<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /usr/src</div><div class="line">wget 链接</div><div class="line">tar -xf node包名</div><div class="line">cd node包</div><div class="line">./config</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure><p></p><ul><li>检查安装是否成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div></pre></td></tr></table></figure></li></ul><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><blockquote><p>目前最新的都已经到<code>5.1.0</code>，这是从0.12版本后，nodejs和iojs(由于部分开发者对管理模式的不满，便fork了nodejs后创建了io.js，采用独立的社区驱动模式运营这个开源项目，每周一个版本迭代)合并了，直接从4.0版本开始发展了，到如今已经是5.1版本。当然，还在持续更新迭代中。</p></blockquote><p><strong>关于nodejs版本号的说明</strong></p><p>偶数位的版本是稳定版本，而一般奇数位的就是非稳定版本，这几乎是在业界大家都达成共识了。比如0.6.x就是稳定版本，而0.11.x就是新功能测试的非稳定版本</p><p>建议选择最新的稳定版本进行使用。由于版本较多，为了方便node版本管理，推荐几个工具：</p><ul><li>osx, linux系统下</li></ul><p>推荐使用n和nvm进行node的多版本管理，n是node的一个模块，TJ大神开发的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g n</div><div class="line">n 5.0.0</div></pre></td></tr></table></figure><ul><li>windows系统下</li></ul><p>推荐使用nvmw进行node的多版本管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 选择一个目录下载nvmw，比如放在C:\Program Files\nvmw</div><div class="line">git clone https://github.com/hakobera/nvmw.git</div><div class="line">// 配置环境变量，在path中增加C:\Program Files\nvmw</div><div class="line">// 运行nvmw命令</div><div class="line">nvmw ls</div><div class="line">nvmw use v5.0.0</div><div class="line">nvmw install v5.0.0</div></pre></td></tr></table></figure><p>不过，这个比较坑，git bash下无法运行，而且，对新版node还不支持</p><h2 id="node初体验"><a href="#node初体验" class="headerlink" title="node初体验"></a>node初体验</h2><h3 id="nodejs的REPL交互环境"><a href="#nodejs的REPL交互环境" class="headerlink" title="nodejs的REPL交互环境"></a>nodejs的REPL交互环境</h3><p>在浏览器中控制台，我们可以直接编写js代码进行运行</p><p>在你的CMD窗口，键入node后回车，即可进入node的repl环境运行js代码。</p><p><a href="http://segmentfault.com/a/1190000002673137" target="_blank" rel="external">更多关于REPL的简单说明戳这里</a></p><h3 id="写个脚本"><a href="#写个脚本" class="headerlink" title="写个脚本"></a>写个脚本</h3><p>代码参见<a href="https://github.com/iUAP-FE/nodejs" target="_blank" rel="external">git仓库</a>。</p><h3 id="起个web服务"><a href="#起个web服务" class="headerlink" title="起个web服务"></a>起个web服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//http.js</div><div class="line"></div><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">var app = http.createServer(function(req, res)&#123;</div><div class="line">  res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</div><div class="line">  res.end(&quot;Hello world&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(1337);</div></pre></td></tr></table></figure><p>是的，就是这样神奇，短短几行代码，就创建了一个web服务，而且，请不要轻视它，这还是一个高性能的web服务器。</p><h2 id="Nodejs模块概述"><a href="#Nodejs模块概述" class="headerlink" title="Nodejs模块概述"></a>Nodejs模块概述</h2><blockquote><p>nodejs的模块分为提供的核心模块以及我们编写的业务模块</p></blockquote><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。</p><p>require方法的参数是模块文件的名字。它分成两种情况。</p><p>第一种情况是参数中含有文件路径，这时路径是相对于当前脚本所在的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myfile = require(&apos;./myfile.js&apos;);</div></pre></td></tr></table></figure><p>第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;);</div></pre></td></tr></table></figure><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http：提供HTTP服务器功能。</div><div class="line">url：解析URL。</div><div class="line">fs：与文件系统交互。</div><div class="line">querystring：解析URL的查询字符串。</div><div class="line">child_process：新建子进程。</div><div class="line">util：提供一系列实用小工具。</div><div class="line">path：处理文件路径。</div><div class="line">crypto：提供加密和解密功能，基本上是对OpenSSL的包装。</div></pre></td></tr></table></figure><p>上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。</p><p>核心模块总是最优先加载的。如果你自己写了一个HTTP模块，<code>require(&#39;http&#39;)</code>加载的还是核心模块。</p><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。</p><p>下面是一个最简单的模块，假定新建一个test.js文件，写入以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = function(str) &#123;</div><div class="line">    alert(str);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p><p>这个模块的使用方法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var test = require(&apos;./test&apos;);</div><div class="line"></div><div class="line">test(&quot;hello world&quot;);</div></pre></td></tr></table></figure><p>上面代码通过require命令加载模块文件test.js（后缀名省略）。</p><h2 id="commonjs代码规范说明"><a href="#commonjs代码规范说明" class="headerlink" title="commonjs代码规范说明"></a>commonjs代码规范说明</h2><p>也许你对上面的代码有所好奇，所以我们就来简单分析下以上代码。</p><p>首先，Node程序它是由许多个模块组成的，每个模块就是一个文件。Node模块采用了CommonJS规范。</p><p>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</p><p>而且，CommonJS规定，每个文件的对外接口是module.exports对象。这个对象的所有属性和方法，都可以被其他文件导入。</p><p>如下，我们来定义一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value + x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 导出变量和方法</span></div><div class="line"><span class="built_in">module</span>.exports.x = x;</div><div class="line"><span class="built_in">module</span>.exports.addX = addX;</div></pre></td></tr></table></figure><p>理解：上面代码通过module.exports对象，定义对外接口，输出变量x和函数addX。module.exports对象是可以被其他文件导入的，它其实就是文件内部与外部通信的桥梁。</p><p>好，继续，我们来引用刚才定义的模块<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(addX(<span class="number">1</span>)); <span class="comment">// 6</span></div></pre></td></tr></table></figure><p></p><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</div><div class="line">module.filename 模块的文件名，带有绝对路径。</div><div class="line">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</div><div class="line">module.parent 返回一个对象，表示调用该模块的模块。</div><div class="line">module.children 返回一个数组，表示该模块要用到的其他模块。</div></pre></td></tr></table></figure><p></p><ul><li><p>module.exports属性<br>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p></li><li><p>exports变量<br>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><h3 id="require命令的解读"><a href="#require命令的解读" class="headerlink" title="require命令的解读"></a>require命令的解读</h3><p>Node.js使用CommonJS模块规范，内置的require命令用于加载模块文件。</p></li></ul><p>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// example.js</div><div class="line">var invisible = function () &#123;</div><div class="line">  console.log(&quot;invisible&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.message = &quot;hi&quot;;</div><div class="line"></div><div class="line">exports.say = function () &#123;</div><div class="line">  console.log(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="require加载模块的规则"><a href="#require加载模块的规则" class="headerlink" title="require加载模块的规则"></a>require加载模块的规则</h3><p>require命令用于加载文件，可以加载后缀名为<code>.js</code> <code>.json</code> <code>.node</code>的文件，比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo = require(&apos;foo&apos;);</div><div class="line">//  等同于</div><div class="line">var foo = require(&apos;foo.js&apos;);</div></pre></td></tr></table></figure><p></p><p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/usr/local/lib/node/bar.js</div><div class="line">/home/user/projects/node_modules/bar.js</div><div class="line">/home/user/node_modules/bar.js</div><div class="line">/home/node_modules/bar.js</div><div class="line">/node_modules/bar.js</div></pre></td></tr></table></figure><p></p><p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p><p>如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p><p>require匹配文件的流程图例</p><p><img src="/img/require.jpg" alt=""></p><h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>npm有两层含义：</p><ul><li>Node.js的开放式模块登记和管理系统，网址为<a href="http://npmjs.org" target="_blank" rel="external">http://npmjs.org</a>。</li><li>Node.js默认的模块管理器，是一个命令行下的软件，用来安装和管理node模块。</li></ul><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。<br>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p><code>step1.</code> npm作为一个NodeJS的模块管理，我们要先配置npm的全局模块的存放路径以及cache的路径，例如我希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立<strong>node_global</strong>及<strong>node_cache</strong>两个文件夹。我们就在cmd中键入两行命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;</div><div class="line">npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot;</div></pre></td></tr></table></figure><p></p><p><code>step2.</code> 下面这一步非常关键，我们需要设置系统变量。进入我的电脑→属性→高级→环境变量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在系统变量下新建“NODE_PATH”</div><div class="line">输入内容“D:\Program Files\nodejs\node_global\node_modules”</div></pre></td></tr></table></figure><p></p><p><code>step3.</code> 安装bower或是gulp等常用工具<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install bower gulp -g</div></pre></td></tr></table></figure><p></p><p>这个时候，你在命令行就可以全局的使用安装的工具了，可以命令行中直接确认<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gulp -v</div><div class="line">bower -v</div></pre></td></tr></table></figure><p></p><p><code>step4.</code> 接下来我们可以进一步学习如何用npm发布自己的包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 初始化一个package</div><div class="line">npm init</div><div class="line">// 添加你的包的管理用户</div><div class="line">npm adduser</div><div class="line">// 发布你的包</div><div class="line">npm publish --tag 0.1.0</div></pre></td></tr></table></figure><p></p><h3 id="学习使用"><a href="#学习使用" class="headerlink" title="学习使用"></a>学习使用</h3><ol><li><p>npm set<br>npm set用来设置环境变量。</p></li><li><p>npm info<br>npm info命令可以查看每个模块的具体信息</p></li><li><p>npm search<br>npm search命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。</p></li><li><p>npm install<br>Node模块采用npm install命令安装。每个模块可以“全局安装”，也可以“本地安装”。两者的差异是模块的安装位置，以及调用方法。</p></li><li><p>npm update<br>npm update 命令可以升级本地安装的模块。</p></li><li><p>npm uninstall<br>卸载掉安装的模块</p></li><li><p>npm publish<br>发布你的包</p></li><li>npm adduser<br>给你的包添加用户信息</li><li>npm cache clear<br>清除缓存</li></ol><h1 id="Chapter-3-–-Nodejs中的对象和核心API"><a href="#Chapter-3-–-Nodejs中的对象和核心API" class="headerlink" title="Chapter 3 – Nodejs中的对象和核心API"></a>Chapter 3 – Nodejs中的对象和核心API</h1><h2 id="node中常用的全局对象"><a href="#node中常用的全局对象" class="headerlink" title="node中常用的全局对象"></a>node中常用的全局对象</h2><blockquote><p>浏览器中运行的js可以访问全局对象window，同样的，在node中运行的js可以访问全局对象global，下面一起了解下在nodejs中都有哪些非常有用的全局对象。</p></blockquote><p><code>global</code>是全局命名空间对象。</p><p>这里需要说明的是，在浏览器中，顶级作用域就是全局作用域。这就是说，在浏览器中，如果当前是在全局作用域内，var something将会声明一个全局变量。在Node中则不同。顶级作用域并非全局作用域，在Node模块里的var something只属于那个模块。</p><h3 id="Console对象"><a href="#Console对象" class="headerlink" title="Console对象"></a>Console对象</h3><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。 Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p><p>console 方法 以下为 console 对象的方法:</p><ul><li>console.log([data][, …]) 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</li><li>console.info([data][, …]) P该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</li><li>console.error([data][, …]) 输出错误消息的。控制台在出现错误时会显示是红色的叉子。</li><li>console.warn([data][, …]) 输出警告消息。控制台出现有黄色的惊叹号。</li><li>console.dir(obj[, options]) 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</li><li>console.time(label) 输出时间，表示计时开始。</li><li>console.timeEnd(label) 结束时间，表示计时结束。</li><li>console.trace(message[, …]) 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 - console.trace 就行了。</li><li>console.assert(value[, message][, …]) 用于判断某个表达式或变量是否为真，接手两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</li><li>console.log()：向标准输出流打印字符并以换行符结束。 console.log 接受若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。 第一个参数是一个字符串，如果没有 参数，只打印一个换行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;Hello world&apos;);</div><div class="line">console.log(&apos;byvoid%diovyb&apos;);</div><div class="line">console.log(&apos;byvoid%diovyb&apos;, 1991);</div><div class="line">console.error()：与console.log() 用法相同，只是向标准错误流输出。 console.trace()：向标准错误流输出当前的调用栈。</div></pre></td></tr></table></figure><h3 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h3><p>Buffer对象Node原生提供的全局对象，用来处理二进制数据的一个接口。JavaScript比较擅长处理Unicode数据，对于处理二进制格式的数据（比如TCP数据流），就不太擅长。Buffer对象就是为了解决这个问题而提供的。该对象也是一个构造函数，它的实例代表了V8引擎分配的一段内存，基本上是一个数组，成员都为整数值。</p><blockquote><p>API说明</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123; [<span class="built_in">Function</span>: Buffer]</div><div class="line">  poolSize: <span class="number">8192</span>,</div><div class="line">  isBuffer: [<span class="built_in">Function</span>: isBuffer],</div><div class="line">  compare: [<span class="built_in">Function</span>: compare],</div><div class="line">  isEncoding: [<span class="built_in">Function</span>],</div><div class="line">  concat: [<span class="built_in">Function</span>],</div><div class="line">  byteLength: [<span class="built_in">Function</span>: byteLength] &#125;</div></pre></td></tr></table></figure><p>暂时存放的一块内存，处理二进制类型文件<br>创建buffer有三种办法：</p><ul><li><code>new Buffer(size)</code>指定长度，然后fill填充内容</li><li><code>new Buffer([&#39;sss&#39;, &#39;xxx&#39;])</code>传入一个数组</li><li><code>new Buffer(&#39;郭永峰&#39;)</code>传入一个字符串</li></ul><h3 id="几个重要的模块内部的局部变量"><a href="#几个重要的模块内部的局部变量" class="headerlink" title="几个重要的模块内部的局部变量"></a>几个重要的模块内部的局部变量</h3><p>模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量， 主要为<strong>filename,</strong>dirname,module, module.exports, exports等。</p><p><strong>__filename</strong><br>注意此属性并不是全局对象的属性，而只是node在我们注入模块的参数，可以在模块内直接使用. _filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径</p><p> // 输出全局变量 <strong>filename 的值<br> console.log(</strong> filename );<br><strong>__dirname</strong><br>注意此属性并不是全局对象的属性，而只是node为我们注入模块的参数，可以在模块内直接使用. __dirname 表示当前执行脚本所在的目录。</p><p>// 输出全局变量 <strong>dirname 的值<br>console.log(</strong> dirname );<br><strong>module</strong><br>代表当前模块本身</p><p><strong>exports</strong><br>模块的导出对象</p><h3 id="path对象"><a href="#path对象" class="headerlink" title="path对象"></a>path对象</h3><p>path.join方法用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\“。</p><p>API接口有：<code>normalize</code> <code>join</code> <code>resolve</code> <code>parse</code> <code>dirname</code> <code>basename</code> `</p><p><strong>path.resolve()</strong>：一个重要的方法</p><p>path.resolve方法用于将相对路径转为绝对路径。</p><p>它可以接受多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 格式</div><div class="line">path.resolve([from ...], to)</div><div class="line"></div><div class="line">// 实例</div><div class="line">path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</div></pre></td></tr></table></figure><p>上面代码的实例，执行效果类似下面的命令。</p><p>bash</p><p>$ cd foo/bar<br>$ cd /tmp/file/<br>$ cd ..<br>$ cd a/../subfile<br>$ pwd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;)</div><div class="line">// &apos;/foo/bar/baz&apos;</div><div class="line"></div><div class="line">path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;)</div><div class="line">// &apos;/tmp/file&apos;</div><div class="line"></div><div class="line">path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)</div><div class="line">// 如果当前目录是/home/myself/node，返回</div><div class="line">// /home/myself/node/wwwroot/static_files/gif/image.gif</div><div class="line">该方法忽略非字符串的参数。</div></pre></td></tr></table></figure><h3 id="stream流对象"><a href="#stream流对象" class="headerlink" title="stream流对象"></a>stream流对象</h3><p>Stream把较大的数据，拆成很小的部分。只要命令部署了Stream接口，就可以把一个流的输出接到另一个流的输入。Node引入了这个概念，通过Stream为异步读写数据提供的统一接口。无论是硬盘数据、网络数据，还是内存数据，都可以采用这个接口读写。</p><p>后面接触的文件系统fs就是基于stream来实现，比较常用的构建工具gulp也是基于流来工作的。</p><p>一个典型的写文件操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var server = http.createServer(function (req, res) &#123;</div><div class="line">  fs.readFile(__dirname + &apos;/data.txt&apos;, function (err, data) &#123;</div><div class="line">    res.end(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(8000);</div></pre></td></tr></table></figure><p>Stream接口分成三类。</p><ul><li>可读数据流接口，用于读取数据。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Readable = require(&apos;stream&apos;).Readable;</div><div class="line"></div><div class="line">var rs = new Readable; rs.push(&apos;beep &apos;); rs.push(&apos;boop\n&apos;); rs.push(null);</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div></pre></td></tr></table></figure><ul><li>可写数据流接口，用于写入数据。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;); var readableStream = fs.createReadStream(&apos;file1.txt&apos;); var writableStream = fs.createWriteStream(&apos;file2.txt&apos;);</div><div class="line"></div><div class="line">readableStream.setEncoding(&apos;utf8&apos;);</div><div class="line"></div><div class="line">readableStream.on(&apos;data&apos;, function(chunk) &#123; writableStream.write(chunk); &#125;);</div></pre></td></tr></table></figure><ul><li>双向数据流接口，用于读取和写入数据，比如Node的tcp、sockets、zlib、crypto都部署了这个接口。</li></ul><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>API接口：argv pid kill stdout stderr strin console nextTick 等</p><p>process 是一个全局变量，即 global 对象的属性。 它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p><p><strong>process.arg</strong><br>是命令行参数数组，第一个元素是node.exe可执行文件的路径,第二个参数是执行的脚本文件所有路径，从第三个元素开始每个参数是一个运行时传入的参数</p><p>console.log(process.argv);<br>以将上代码保存为argv.js,然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">E:\nodejs\test&gt;node argv.js test input</div></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ &apos;C:\\Program Files\\nodejs\\node.exe&apos;,</div><div class="line">  &apos;E:\\testjus\\argv.js&apos;,</div><div class="line">  &apos;test&apos;,</div><div class="line">  &apos;input&apos; ]</div></pre></td></tr></table></figure><p><strong>process.stdout</strong><br>标准输出流，通常我们使用的console.log往标准输出打印字符，其实调用的就是process.stdout.write()函数</p><p><strong>process.stdin</strong><br>标准输入流，初始时它是暂停的，要想从标准输入读取数据，必须恢复流，并手动编写流的事件响应函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.stdin.resume();</div><div class="line"></div><div class="line">process.stdin.on(&apos;data&apos;,function(data)&#123;</div><div class="line">  process.stdout.write(&apos;从控制台读入用户输入的字符&apos;+data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="学习node中的核心模块"><a href="#学习node中的核心模块" class="headerlink" title="学习node中的核心模块"></a>学习node中的核心模块</h2><h3 id="Fs模块"><a href="#Fs模块" class="headerlink" title="Fs模块"></a>Fs模块</h3><p>fs是filesystem的缩写，该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。但是，这个模块几乎对所有操作提供异步和同步两种操作方式，供开发者选择。</p><p>readFileSync()<br>readFileSync方法用于同步读取文件，返回一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = fs.readFileSync(fileName, &quot;utf8&quot;);</div><div class="line"></div><div class="line">// 将文件按行拆成数组</div><div class="line">text.split(/\r?\n/).forEach(function (line) &#123;</div><div class="line">  // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>writeFileSync()<br>writeFileSync方法用于同步写入文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.writeFileSync(fileName, str, &apos;utf8&apos;);</div></pre></td></tr></table></figure><p>mkdir()，writeFile()，readfile()<br>mkdir方法用于新建目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">fs.mkdir(&apos;./helloDir&apos;,0777, function (err) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>mkdir接受三个参数，第一个是目录名，第二个是权限值，第三个是回调函数。</p><p>writeFile方法用于写入文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">fs.writeFile(&apos;./helloDir/message.txt&apos;, &apos;Hello Node&apos;, function (err) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(&apos;文件写入成功&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>readfile方法用于读取文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">fs.readFile(&apos;./helloDir/message.txt&apos;,&apos;UTF-8&apos; ,function (err, data) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>上面代码使用readFile方法读取文件。readFile方法的第一个参数是文件名，第二个参数是文件编码，第三个参数是回调函数。可用的文件编码包括“ascii”、“utf8”和“base64”。如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法，将其转为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fs.readFile(&apos;example_log.txt&apos;, function (err, logData) &#123;</div><div class="line">  if (err) throw err;</div><div class="line">  var text = logData.toString();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>readFile方法是异步操作，所以必须小心，不要同时发起多个readFile请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 1; i &lt;= 1000; i++) &#123;</div><div class="line">  fs.readFile(&apos;./&apos;+i+&apos;.txt&apos;, function() &#123;</div><div class="line">     // do something with the file</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码会同时发起1000个readFile异步请求，很快就会耗尽系统资源。</p><h3 id="Http模块"><a href="#Http模块" class="headerlink" title="Http模块"></a>Http模块</h3><p>Http模块主要用于搭建HTTP服务。使用Node.js搭建HTTP服务器非常简单。</p><ul><li>处理GET请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var http = require(&quot;http&quot;);</div><div class="line"></div><div class="line">http.createServer(function(req, res) &#123;</div><div class="line"></div><div class="line">// 主页</div><div class="line">if (req.url == &quot;/&quot;) &#123;</div><div class="line">  res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);</div><div class="line">  res.end(&quot;Welcome to the homepage!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// About页面</div><div class="line">else if (req.url == &quot;/about&quot;) &#123;</div><div class="line">  res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);</div><div class="line">  res.end(&quot;Welcome to the about page!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 404错误</div><div class="line">else &#123;</div><div class="line">  res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);</div><div class="line">  res.end(&quot;404 error! File not found.&quot;);</div><div class="line">&#125;</div><div class="line">&#125;).listen(8080, &quot;localhost&quot;);</div></pre></td></tr></table></figure><p>上面代码第一行var http = require(“http”)，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例，将它赋给变量http。</p><p>ceateServer方法接受一个函数作为参数，该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法表示，服务器端回应一个HTTP头信息；response.end方法表示，服务器端回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。</p><p>将上面这几行代码保存成文件app.js，然后用node调用这个文件，服务器就开始运行了。</p><ul><li>处理POST请求</li></ul><p>当客户端采用POST方法发送数据时，服务器端可以对data和end两个事件，设立监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function (req, res) &#123; var content = &quot;&quot;;</div><div class="line"></div><div class="line">req.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  content += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">req.on(&apos;end&apos;, function () &#123;</div><div class="line">  res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</div><div class="line">  res.write(&quot;You&apos;ve sent: &quot; + content);</div><div class="line">  res.end();</div><div class="line">&#125;);</div><div class="line">&#125;).listen(8080);</div></pre></td></tr></table></figure><p><strong>模块属性</strong></p><p>（1）HTTP请求的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">headers：HTTP请求的头信息。</div><div class="line">url：请求的路径。</div></pre></td></tr></table></figure><p><strong>模块方法</strong></p><p>（1）http模块的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">createServer(callback)：创造服务器实例。</div></pre></td></tr></table></figure><p>（2）服务器实例的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listen(port)：启动服务器监听指定端口。</div></pre></td></tr></table></figure><p>（3）HTTP回应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setHeader(key, value)：指定HTTP头信息。</div><div class="line">write(str)：指定HTTP回应的内容。</div><div class="line">end()：发送HTTP回应。</div></pre></td></tr></table></figure><h3 id="Events模块和异步编程"><a href="#Events模块和异步编程" class="headerlink" title="Events模块和异步编程"></a>Events模块和异步编程</h3><p>Events模块是node.js对“发布/订阅”模式（publish/subscribe）的部署。一个对象通过这个模块，向另一个对象传递消息。该模块通过EventEmitter属性，提供了一个构造函数。该构造函数的实例具有on方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被EventEmitter实例的on方法监听到。</p><p>下面是一个实例，先建立一个消息中心，然后通过on方法，为各种事件指定回调函数，从而将程序转为事件驱动型，各个模块之间通过事件联系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var EventEmitter = require(&quot;events&quot;).EventEmitter;</div><div class="line"></div><div class="line">var ee = new EventEmitter();</div><div class="line">ee.on(&quot;someEvent&quot;, function () &#123;</div><div class="line">  console.log(&quot;event has occured&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ee.emit(&quot;someEvent&quot;);</div></pre></td></tr></table></figure><p>Events模块的作用，还在于其他模块可以部署EventEmitter接口，从而也能够订阅和发布消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</div><div class="line"></div><div class="line">function Dog(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dog.prototype.__proto__ = EventEmitter.prototype;</div><div class="line">// 另一种写法</div><div class="line">// Dog.prototype = Object.create(EventEmitter.prototype);</div><div class="line"></div><div class="line">var simon = new Dog(&apos;simon&apos;);</div><div class="line"></div><div class="line">simon.on(&apos;bark&apos;, function()&#123;</div><div class="line">  console.log(this.name + &apos; barked&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(function()&#123;</div><div class="line">  simon.emit(&apos;bark&apos;);</div><div class="line">&#125;, 500);</div></pre></td></tr></table></figure><p>上面代码新建了一个构造函数Dog，然后让其继承EventEmitter，因此Dog就拥有了EventEmitter的接口。最后，为Dog的实例指定bark事件的监听函数，再使用EventEmitter的emit方法，触发bark事件。</p><h1 id="Chapter-4-–-Node-js开发实战"><a href="#Chapter-4-–-Node-js开发实战" class="headerlink" title="Chapter 4 – Node.js开发实战"></a>Chapter 4 – Node.js开发实战</h1><blockquote><p>导读：通过对express、jade、angular、mongodb等技术结合的一个示例代码，和大家分享涉及的技术点。</p></blockquote><h2 id="express的使用"><a href="#express的使用" class="headerlink" title="express的使用"></a>express的使用</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>基于 Node.js 平台，快速、开放、极简的 web 开发框架。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express express-generator -g</div></pre></td></tr></table></figure><h3 id="生成项目脚手架代码"><a href="#生成项目脚手架代码" class="headerlink" title="生成项目脚手架代码"></a>生成项目脚手架代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">express myapp</div></pre></td></tr></table></figure><h2 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h2><p>jade本身是基于nodejs开发的模板引擎</p><h2 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h2><p>angular是一个前端MVC框架，在这里会和大家简单介绍基于nodejs的项目对angular的使用</p><h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>mongodb是目前流行的noSQL数据库，因其简单实用而流行。</p></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"> <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="semifi wechat" style="width:200px;max-width:100%"><div>欢迎您扫一扫上面的微信号，添加好友！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>觉得不错就赏一个吧`(*∩_∩*)′</div> <button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'> <span>赏</span></button><div id="QR" style="display:none"><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/uploads/alipay-reward-image.jpg" alt="semifi Alipay"><p>支付宝打赏</p></div></div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/node/" rel="tag">#node</a> <a href="/tags/JavaScript/" rel="tag">#JavaScript</a> <a href="/tags/Node/" rel="tag">#Node</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/01/20/webpack入门及实践/" rel="next" title="webpack入门及实践"><i class="fa fa-chevron-left"></i> webpack入门及实践</a></div><div class="post-nav-prev post-nav-item"> <a href="/2016/04/20/前端模板/" rel="prev" title="对前端模板的思考">对前端模板的思考<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="jiathis_style"><a class="jiathis_button_tsina"></a><a class="jiathis_button_tqq"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_cqq"></a><a class="jiathis_button_douban"></a><a class="jiathis_button_renren"></a><a class="jiathis_button_qzone"></a><a class="jiathis_button_kaixin001"></a><a class="jiathis_button_copy"></a><a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script></div></div></div><p>热评文章</p><div class="ds-top-threads" data-range="weekly" data-num-items="4"></div><div class="comments" id="comments"><div class="ds-thread" data-thread-key="2016/03/20/Node-js知识详解/" data-title="Node.js知识详解" data-url="http://pengfei6.github.io/2016/03/20/Node-js知识详解/"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars3.githubusercontent.com/u/18401251?v=3&s=460" alt="semifi"><p class="site-author-name" itemprop="name">semifi</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-–-Node-js入门知识"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1 – Node.js入门知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍"><span class="nav-number">1.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要学nodejs"><span class="nav-number">1.2.</span> <span class="nav-text">为什么要学nodejs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nodejs市场活跃"><span class="nav-number">1.2.1.</span> <span class="nav-text">Nodejs市场活跃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nodejs应用广泛"><span class="nav-number">1.2.2.</span> <span class="nav-text">Nodejs应用广泛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐关注"><span class="nav-number">1.2.3.</span> <span class="nav-text">推荐关注</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeJS优缺点及适用场景讨论"><span class="nav-number">1.3.</span> <span class="nav-text">NodeJS优缺点及适用场景讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决并发连接的问题"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">解决并发连接的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决I-O阻塞的问题"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">解决I/O阻塞的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#综合对比分析"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">综合对比分析</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-–-Node-js基础知识"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2 – Node.js基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">2.1.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#windows上安装"><span class="nav-number">2.1.1.</span> <span class="nav-text">windows上安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mac上安装"><span class="nav-number">2.1.2.</span> <span class="nav-text">mac上安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux上安装"><span class="nav-number">2.1.3.</span> <span class="nav-text">linux上安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本说明"><span class="nav-number">2.1.4.</span> <span class="nav-text">版本说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node初体验"><span class="nav-number">2.2.</span> <span class="nav-text">node初体验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nodejs的REPL交互环境"><span class="nav-number">2.2.1.</span> <span class="nav-text">nodejs的REPL交互环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写个脚本"><span class="nav-number">2.2.2.</span> <span class="nav-text">写个脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#起个web服务"><span class="nav-number">2.2.3.</span> <span class="nav-text">起个web服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nodejs模块概述"><span class="nav-number">2.3.</span> <span class="nav-text">Nodejs模块概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载模块"><span class="nav-number">2.3.1.</span> <span class="nav-text">加载模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心模块"><span class="nav-number">2.3.2.</span> <span class="nav-text">核心模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义模块"><span class="nav-number">2.3.3.</span> <span class="nav-text">自定义模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commonjs代码规范说明"><span class="nav-number">2.4.</span> <span class="nav-text">commonjs代码规范说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#module对象"><span class="nav-number">2.4.1.</span> <span class="nav-text">module对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#require命令的解读"><span class="nav-number">2.4.2.</span> <span class="nav-text">require命令的解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#require加载模块的规则"><span class="nav-number">2.4.3.</span> <span class="nav-text">require加载模块的规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#npm包管理器"><span class="nav-number">2.5.</span> <span class="nav-text">npm包管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">2.5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局配置"><span class="nav-number">2.5.2.</span> <span class="nav-text">全局配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习使用"><span class="nav-number">2.5.3.</span> <span class="nav-text">学习使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-–-Nodejs中的对象和核心API"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 – Nodejs中的对象和核心API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#node中常用的全局对象"><span class="nav-number">3.1.</span> <span class="nav-text">node中常用的全局对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Console对象"><span class="nav-number">3.1.1.</span> <span class="nav-text">Console对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer对象"><span class="nav-number">3.1.2.</span> <span class="nav-text">Buffer对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个重要的模块内部的局部变量"><span class="nav-number">3.1.3.</span> <span class="nav-text">几个重要的模块内部的局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#path对象"><span class="nav-number">3.1.4.</span> <span class="nav-text">path对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream流对象"><span class="nav-number">3.1.5.</span> <span class="nav-text">stream流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process"><span class="nav-number">3.1.6.</span> <span class="nav-text">process</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习node中的核心模块"><span class="nav-number">3.2.</span> <span class="nav-text">学习node中的核心模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fs模块"><span class="nav-number">3.2.1.</span> <span class="nav-text">Fs模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http模块"><span class="nav-number">3.2.2.</span> <span class="nav-text">Http模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Events模块和异步编程"><span class="nav-number">3.2.3.</span> <span class="nav-text">Events模块和异步编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-4-–-Node-js开发实战"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4 – Node.js开发实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#express的使用"><span class="nav-number">4.1.</span> <span class="nav-text">express的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-1"><span class="nav-number">4.1.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成项目脚手架代码"><span class="nav-number">4.1.3.</span> <span class="nav-text">生成项目脚手架代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ejs"><span class="nav-number">4.2.</span> <span class="nav-text">ejs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#angular"><span class="nav-number">4.3.</span> <span class="nav-text">angular</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mongodb"><span class="nav-number">4.4.</span> <span class="nav-text">mongodb</span></a></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 - <span itemprop="copyrightYear">2016</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">semifi</span></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"semifi"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("MHRWKTp3KM39kKFz1G9WjgcC-gzGzoHsz","VltbWrna4wlHYCjjVs7vnvLz")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var r=e[i],s=r.get("url"),l=r.get("time"),c=document.getElementById(s);$(c).find(t).text(l)}for(var i=0;i<n.length;i++){var s=n[i],c=document.getElementById(s),u=$(c).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e,s=new AV.ACL;s.setPublicReadAccess(!0),s.setPublicWriteAccess(!0),r.setACL(s),r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js"></script></body></html><script type="text/javascript" src="/js/src/particle.js"></script><script type="text/javascript" src="/js/src/love.js"></script>